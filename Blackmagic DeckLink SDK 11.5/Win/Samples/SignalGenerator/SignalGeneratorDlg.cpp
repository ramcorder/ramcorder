/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// SignalGeneratorDlg.cpp : implementation file
//

#include "stdafx.h"
#include <map>
#include <utility>
#include "SignalGenerator.h"
#include "SignalGeneratorDlg.h"
#include "PreviewWindow.h"
#include "ProfileCallback.h"
#include "DeckLinkOutputDevice.h"
#include "DeckLinkDeviceDiscovery.h"
#define _USE_MATH_DEFINES
#include <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const unsigned long		kAudioWaterlevel = 48000;

// SD 75% Colour Bars
static DWORD gSD75pcColourBars[8] =
{
	0xeb80eb80, 0xa28ea22c, 0x832c839c, 0x703a7048,
	0x54c654b8, 0x41d44164, 0x237223d4, 0x10801080
};

// HD 75% Colour Bars
static DWORD gHD75pcColourBars[8] =
{
	0xeb80eb80, 0xa888a82c, 0x912c9193, 0x8534853f,
	0x3fcc3fc1, 0x33d4336d, 0x1c781cd4, 0x10801080
};

// Supported number audio channels
static const int gAudioChannels[] = { 2, 8, 16 };

// Supported pixel formats map to string represenatation and boolean if RGB format
static const std::map<BMDPixelFormat, std::pair<CString, BOOL>> kPixelFormats = {
	std::make_pair(bmdFormat8BitYUV,	std::make_pair(_T("8-bit YUV"), FALSE)),
	std::make_pair(bmdFormat10BitYUV,	std::make_pair(_T("10-bit YUV"), FALSE)),
	std::make_pair(bmdFormat8BitARGB,	std::make_pair(_T("8-bit RGB"), TRUE)),
	std::make_pair(bmdFormat10BitRGB,	std::make_pair(_T("10-bit RGB"), TRUE)),
};

CSignalGeneratorDlg::CSignalGeneratorDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSignalGeneratorDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	
	// Initialize instance variables
	m_running = false;
	m_scheduledPlaybackStopped = false;
	
	m_videoFrameBlack = NULL;
	m_videoFrameBars = NULL;
	m_audioBuffer = NULL;

	m_selectedDevice = NULL;
	m_selectedDisplayMode = NULL;
	m_selectedVideoOutputFlags = bmdVideoOutputFlagDefault;

	InitializeConditionVariable(&m_stopPlaybackCondition);
	InitializeCriticalSection(&m_stopPlaybackLock);
}

void CSignalGeneratorDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDOK, m_startButton);
	DDX_Control(pDX, IDC_COMBO_DEVICE, m_deviceListCombo);
	DDX_Control(pDX, IDC_COMBO_SIGNAL, m_outputSignalCombo);
	DDX_Control(pDX, IDC_COMBO_CHANNELS, m_audioChannelCombo);
	DDX_Control(pDX, IDC_COMBO_AUDIO_DEPTH, m_audioSampleDepthCombo);
	DDX_Control(pDX, IDC_COMBO_VIDEO_FORMAT, m_videoFormatCombo);
	DDX_Control(pDX, IDC_COMBO_PIXEL_FORMAT, m_pixelFormatCombo);
	DDX_Control(pDX, IDC_PREVIEW_BOX, m_previewBox);
}

BEGIN_MESSAGE_MAP(CSignalGeneratorDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDOK, &CSignalGeneratorDlg::OnBnClickedOk)
	ON_CBN_SELCHANGE(IDC_COMBO_DEVICE, &CSignalGeneratorDlg::OnNewDeviceSelected)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CSignalGeneratorDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CSignalGeneratorDlg::OnRemoveDevice)
	ON_MESSAGE(WM_UPDATE_PROFILE_MESSAGE, &CSignalGeneratorDlg::OnProfileUpdate)
	ON_WM_CLOSE()
	ON_CBN_SELCHANGE(IDC_COMBO_VIDEO_FORMAT, &CSignalGeneratorDlg::OnNewVideoFormatSelected)
END_MESSAGE_MAP()


void CSignalGeneratorDlg::RefreshDisplayModeMenu(void)
{
	// Populate the display mode combo with a list of display modes supported by the installed DeckLink card
	IDeckLinkDisplayModeIterator*	displayModeIterator;
	IDeckLinkDisplayMode*			deckLinkDisplayMode;
	IDeckLinkOutput*				deckLinkOutput;

	for (int i = 1; i < m_videoFormatCombo.GetCount(); i++)
	{
		deckLinkDisplayMode = (IDeckLinkDisplayMode*)m_videoFormatCombo.GetItemDataPtr(i-1);
		deckLinkDisplayMode->Release();
	}
	m_videoFormatCombo.ResetContent();

	deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	if (deckLinkOutput->GetDisplayModeIterator(&displayModeIterator) != S_OK)
		return;
	
	while (displayModeIterator->Next(&deckLinkDisplayMode) == S_OK)
	{
		BSTR					modeName;
		int						newIndex;
		HRESULT					hr;
		BOOL					supported = FALSE;
		BMDSupportedVideoModeFlags	flags = bmdSupportedVideoModeDualStream3D;

		// Check that display mode is supported with the active profile
		hr = deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, deckLinkDisplayMode->GetDisplayMode(), bmdFormatUnspecified, bmdNoVideoOutputConversion, bmdSupportedVideoModeDefault, NULL, &supported);
		if (hr != S_OK || !supported)
		{
			deckLinkDisplayMode->Release();
			continue;
		}

		if (deckLinkDisplayMode->GetName(&modeName) != S_OK)
		{
			deckLinkDisplayMode->Release();
			continue;
		}
		
		CString modeNameCString(modeName);
		newIndex = m_videoFormatCombo.AddString(modeNameCString);
		m_videoFormatCombo.SetItemDataPtr(newIndex, deckLinkDisplayMode); 

		if (m_videoFormatCombo.GetCount() == 1)
		{
			// We have added our first item, refresh pixel format menu
			m_videoFormatCombo.SetCurSel(0);
			OnNewVideoFormatSelected();
		}

		// Check Dual Stream 3D support with any pixel format
		hr = deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, deckLinkDisplayMode->GetDisplayMode(), bmdFormatUnspecified, bmdNoVideoOutputConversion, flags, NULL, &supported);
		if (hr != S_OK || ! supported)
		{
			SysFreeString(modeName);
			continue;
		}

		CString modeName3DCString(modeName);
		modeName3DCString += _T(" 3D");
		newIndex = m_videoFormatCombo.AddString(modeName3DCString);
		m_videoFormatCombo.SetItemDataPtr(newIndex, deckLinkDisplayMode);
		deckLinkDisplayMode->AddRef();

		SysFreeString(modeName);
	}

	displayModeIterator->Release();

	m_startButton.EnableWindow(m_videoFormatCombo.GetCount() > 0);
}


void CSignalGeneratorDlg::RefreshPixelFormatMenu(void)
{
	// Populate the pixel format mode combo with a list of pixel formats supported by the installed DeckLink card
	IDeckLinkOutput* deckLinkOutput;

	m_pixelFormatCombo.ResetContent();

	deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	for (auto& pixelFormat : kPixelFormats)
	{
		HRESULT					hr;
		int						newIndex;
		BOOL					supported;
		CString					pixelFormatString;
		BMDSupportedVideoModeFlags	flags = (m_selectedVideoOutputFlags == bmdVideoOutputDualStream3D) ? bmdSupportedVideoModeDualStream3D : bmdSupportedVideoModeDefault;

		std::tie(pixelFormatString, std::ignore) = pixelFormat.second;

		hr = deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, m_selectedDisplayMode->GetDisplayMode(), pixelFormat.first, bmdNoVideoOutputConversion, flags, NULL, &supported);
		if (hr != S_OK || ! supported)
			continue;

		newIndex = m_pixelFormatCombo.AddString(pixelFormatString);
		m_pixelFormatCombo.SetItemData(newIndex, pixelFormat.first);
	}

	m_pixelFormatCombo.SetCurSel(0);
}


void CSignalGeneratorDlg::RefreshAudioChannelMenu(void)
{
	IDeckLink*				deckLink;
	IDeckLinkProfileAttributes*	deckLinkAttributes = NULL;
	LONGLONG				maxAudioChannels;

	deckLink = m_selectedDevice->GetDeckLinkInstance();

	// Get DeckLink attributes to determine number of audio channels
	if (deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes) != S_OK)
		goto bail;

	// Get max number of audio channels supported by DeckLink device
	if (deckLinkAttributes->GetInt(BMDDeckLinkMaximumAudioChannels, &maxAudioChannels) != S_OK)
		goto bail;

	m_audioChannelCombo.ResetContent();

	// Scan through Audio channel popup menu and disable invalid entries
	for (int i = 0; i < sizeof(gAudioChannels) / sizeof(*gAudioChannels); i++)
	{
		if (maxAudioChannels < (LONGLONG)gAudioChannels[i])
			break;

		CString audioChannelString;
		audioChannelString.Format(_T("%d"), gAudioChannels[i]);

		m_audioChannelCombo.AddString(audioChannelString);
		m_audioChannelCombo.SetItemData(i, gAudioChannels[i]);
	}

	m_audioChannelCombo.SetCurSel(m_audioChannelCombo.GetCount() - 1);

bail:
	if (deckLinkAttributes)
		deckLinkAttributes->Release();
}

// CSignalGeneratorDlg message handlers

BOOL CSignalGeneratorDlg::OnInitDialog()
{
	bool			success = false;
	
	CDialog::OnInitDialog();
	
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// Set the item data for combo box entries to store audio channel count and sample depth information
	m_outputSignalCombo.SetItemData(0, kOutputSignalPip);
	m_outputSignalCombo.SetItemData(1, kOutputSignalDrop);
	//
	m_audioSampleDepthCombo.SetItemData(0, 16);	// 16-bit samples
	m_audioSampleDepthCombo.SetItemData(1, 32);	// 32-bit samples

	// Select the first item in each combo box
	m_outputSignalCombo.SetCurSel(0);
	m_audioSampleDepthCombo.SetCurSel(0);
	m_pixelFormatCombo.SetCurSel(0);

	//
	// Create and enable DeckLink device discovery callback interface object
	m_deckLinkDiscovery = new DeckLinkDeviceDiscovery(this);
	if (m_deckLinkDiscovery != NULL)
	{
		if (!m_deckLinkDiscovery->enable())
		{
			MessageBox(_T("This application requires the DeckLink drivers installed.\nPlease install the Blackmagic DeckLink drivers to use the features of this application."), _T("Error"));
			goto bail;
		}
	}

	// Create and initialize preview helper
	m_previewWindow = new PreviewWindow();
	if (m_previewWindow->init(&m_previewBox) == false)
	{
		MessageBox(_T("This application was unable to initialise the preview window"), _T("Error"));
	}

	// Create profile callback interface object
	m_profileCallback = new ProfileCallback(this);
	if (m_profileCallback == NULL)
	{
		MessageBox(_T("This application was unable to create profile callback class"), _T("Error"));
	}

bail:
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSignalGeneratorDlg::EnableInterface (BOOL enable)
{
	// Set the enable state of user interface elements
	m_deviceListCombo.EnableWindow(enable);
	m_outputSignalCombo.EnableWindow(enable);
	m_audioChannelCombo.EnableWindow(enable);
	m_audioSampleDepthCombo.EnableWindow(enable);
	m_videoFormatCombo.EnableWindow(enable);
	m_pixelFormatCombo.EnableWindow(enable);
}

void CSignalGeneratorDlg::OnBnClickedOk()
{
	if (m_running == false)
		StartRunning();
	else
		StopRunning();
}

void CSignalGeneratorDlg::OnNewDeviceSelected()
{
	int		selectedDeviceIndex;

	selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	// Release profile callback from existing selected device
	if (m_selectedDevice != NULL)
	{
		IDeckLinkProfileManager* profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != NULL)
			profileManager->SetCallback(NULL);
	}
	
	m_selectedDevice = (DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex);

	// Register profile callback with newly selected device's profile manager
	if (m_selectedDevice != NULL)
	{
		IDeckLinkProfileManager* profileManager = m_selectedDevice->GetDeviceProfileManager();
		if (profileManager != NULL)
			profileManager->SetCallback(m_profileCallback);
	}

	// Update the video mode popup menu
	RefreshDisplayModeMenu();

	// Update available audio channels
	RefreshAudioChannelMenu();
}


void CSignalGeneratorDlg::OnNewVideoFormatSelected()
{
	int			selectedVideoFormatIndex;
	CString		videoFormatName;

	selectedVideoFormatIndex = m_videoFormatCombo.GetCurSel();
	if (selectedVideoFormatIndex < 0)
		return;

	m_selectedDisplayMode = (IDeckLinkDisplayMode*)m_videoFormatCombo.GetItemDataPtr(selectedVideoFormatIndex);

	m_videoFormatCombo.GetLBText(selectedVideoFormatIndex, videoFormatName);
	m_selectedVideoOutputFlags = (videoFormatName.Find(_T(" 3D"), 0) != -1) ? bmdVideoOutputDualStream3D : bmdVideoOutputFlagDefault;

	RefreshPixelFormatMenu();
}

void CSignalGeneratorDlg::AddDevice(IDeckLink* deckLink)
{
	int deviceIndex;
	DeckLinkOutputDevice* newDevice = new DeckLinkOutputDevice(this, deckLink);

	// Initialise new DeckLinkDevice object
	if (!newDevice->Init())
	{
		// Device does not have IDeckLinkOutput interface, eg it is a DeckLink Mini Recorder
		newDevice->Release();
		return;
	}

	// Add this DeckLink device to the device list
	deviceIndex = m_deviceListCombo.AddString(newDevice->GetDeviceName());
	if (deviceIndex < 0)
		return;

	m_deviceListCombo.SetItemDataPtr(deviceIndex, newDevice);

	if (m_deviceListCombo.GetCount() == 1)
	{
		// We have added our first item, refresh and enable UI
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();
	}
}

void CSignalGeneratorDlg::RemoveDevice(IDeckLink* deckLink)
{
	int deviceIndex = -1;
	DeckLinkOutputDevice* deviceToRemove = NULL;

	// Find the combo box entry to remove (there may be multiple entries with the same name, but each
	// will have a different data pointer).
	for (deviceIndex = 0; deviceIndex < m_deviceListCombo.GetCount(); ++deviceIndex)
	{
		deviceToRemove = (DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(deviceIndex);
		if (deviceToRemove->GetDeckLinkInstance() == deckLink)
			break;
	}

	if (deviceToRemove == NULL)
		return;

	// Remove device from list
	m_deviceListCombo.DeleteString(deviceIndex);

	// If playback is ongoing, stop it
	if ((m_selectedDevice == deviceToRemove) && m_running)
		StopRunning();

	// Check how many devices are left
	if (m_deviceListCombo.GetCount() == 0)
	{
		// We have removed the last device, disable the interface.
		m_startButton.EnableWindow(FALSE);
		EnableInterface(FALSE);
		m_selectedDevice = NULL;
	}
	else if (m_selectedDevice == deviceToRemove)
	{
		// The device that was removed was the one selected in the UI.
		// Select the first available device in the list and reset the UI.
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();
	}

	// Release DeckLinkDevice instance
	deviceToRemove->Release();
}

static int GetRowBytes(BMDPixelFormat pixelFormat, ULONG frameWidth)
{
	int bytesPerRow;

	// Refer to DeckLink SDK Manual - 2.7.4 Pixel Formats
	switch (pixelFormat)
	{
	case bmdFormat8BitYUV:
		bytesPerRow = frameWidth * 2;
		break;

	case bmdFormat10BitYUV:
		bytesPerRow = ((frameWidth + 47) / 48) * 128;
		break;

	case bmdFormat10BitRGB:
		bytesPerRow = ((frameWidth + 63) / 64) * 256;
		break;

	case bmdFormat8BitARGB:
	case bmdFormat8BitBGRA:
	default:
		bytesPerRow = frameWidth * 4;
		break;
	}

	return bytesPerRow;
}

SignalGenerator3DVideoFrame* CSignalGeneratorDlg::CreateOutputFrame(std::function<void(IDeckLinkVideoFrame*, bool)> fillFrame)
{
	IDeckLinkOutput*                deckLinkOutput;
	IDeckLinkMutableVideoFrame*		referenceFrameLeft	= NULL;
	IDeckLinkMutableVideoFrame*		referenceFrameRight	= NULL;
	IDeckLinkMutableVideoFrame*		scheduleFrameLeft	= NULL;
	IDeckLinkMutableVideoFrame*		scheduleFrameRight	= NULL;
	HRESULT							hr;
	BMDPixelFormat					pixelFormat;
	int								bytesPerRow;
	int								referenceBytesPerRow;
	IDeckLinkVideoConversion*		frameConverter		= NULL;
	SignalGenerator3DVideoFrame*	ret					= NULL;

	pixelFormat = (BMDPixelFormat)m_pixelFormatCombo.GetItemData(m_pixelFormatCombo.GetCurSel());
	bytesPerRow = GetRowBytes(pixelFormat, m_frameWidth);
	referenceBytesPerRow = GetRowBytes(bmdFormat8BitYUV, m_frameWidth);

	deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	hr = CoCreateInstance(CLSID_CDeckLinkVideoConversion, NULL, CLSCTX_ALL, IID_IDeckLinkVideoConversion, (void**)&frameConverter);
	if (hr != S_OK)
		goto bail;

	hr = deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, referenceBytesPerRow, bmdFormat8BitYUV, bmdFrameFlagDefault, &referenceFrameLeft);
	if (hr != S_OK)
		goto bail;

	fillFrame(referenceFrameLeft, false);

	if (pixelFormat == bmdFormat8BitYUV)
	{
		// Frame is already 8-bit YUV, no conversion required
		scheduleFrameLeft = referenceFrameLeft;
		scheduleFrameLeft->AddRef();
	}
	else
	{
		hr = deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, bytesPerRow, pixelFormat, bmdFrameFlagDefault, &scheduleFrameLeft);
		if (hr != S_OK)
			goto bail;

		hr = frameConverter->ConvertFrame(referenceFrameLeft, scheduleFrameLeft);
		if (hr != S_OK)
			goto bail;
	}

	// If dual-stream 3D, generate right-eye frame
	if (m_selectedVideoOutputFlags == bmdVideoOutputDualStream3D)
	{
		hr = deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, referenceBytesPerRow, bmdFormat8BitYUV, bmdFrameFlagDefault, &referenceFrameRight);
		if (hr != S_OK)
			goto bail;

		fillFrame(referenceFrameRight, true);

		if (pixelFormat == bmdFormat8BitYUV)
		{
			// Frame is already 8-bit YUV, no conversion required
			scheduleFrameRight = referenceFrameRight;
			scheduleFrameRight->AddRef();
		}
		else
		{
			hr = deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, bytesPerRow, pixelFormat, bmdFrameFlagDefault, &scheduleFrameRight);
			if (hr != S_OK)
				goto bail;

			hr = frameConverter->ConvertFrame(referenceFrameRight, scheduleFrameRight);
			if (hr != S_OK)
				goto bail;
		}
	}

	ret = new SignalGenerator3DVideoFrame(scheduleFrameLeft, scheduleFrameRight);

bail:
	if (referenceFrameLeft)
	{
		referenceFrameLeft->Release();
		referenceFrameLeft = NULL;
	}
	if (referenceFrameRight)
	{
		referenceFrameRight->Release();
		referenceFrameRight = NULL;
	}
	if (scheduleFrameLeft)
	{
		scheduleFrameLeft->Release();
		scheduleFrameLeft = NULL;
	}
	if (scheduleFrameRight)
	{
		scheduleFrameRight->Release();
		scheduleFrameRight = NULL;
	}
	if (frameConverter)
	{
		frameConverter->Release();
		frameConverter = NULL;
	}

	return ret;
}

void	CSignalGeneratorDlg::StartRunning ()
{
	IDeckLinkOutput*	deckLinkOutput;
	BOOL				output444;
	HRESULT				result;

	// Determine the audio and video properties for the output stream
	m_outputSignal = (OutputSignal)m_outputSignalCombo.GetCurSel();
	m_audioChannelCount = m_audioChannelCombo.GetItemData(m_audioChannelCombo.GetCurSel());
	m_audioSampleDepth = (BMDAudioSampleType)m_audioSampleDepthCombo.GetItemData(m_audioSampleDepthCombo.GetCurSel());
	m_audioSampleRate = bmdAudioSampleRate48kHz;
	//
	// - Extract the IDeckLinkDisplayMode from the display mode popup menu (stashed in the item's tag)
	m_frameWidth = m_selectedDisplayMode->GetWidth();
	m_frameHeight = m_selectedDisplayMode->GetHeight();
	m_selectedDisplayMode->GetFrameRate(&m_frameDuration, &m_frameTimescale);
	// Calculate the number of frames per second, rounded up to the nearest integer.  For example, for NTSC (29.97 FPS), framesPerSecond == 30.
	m_framesPerSecond = (unsigned long)((m_frameTimescale + (m_frameDuration-1))  /  m_frameDuration);
	
	// Set the output to 444 if RGB mode is selected
	try
	{
		std::tie(std::ignore, output444) = kPixelFormats.at((BMDPixelFormat)m_pixelFormatCombo.GetItemData(m_pixelFormatCombo.GetCurSel()));
	}
	catch (std::out_of_range)
	{
		goto bail;
	}

	result = m_selectedDevice->GetDeviceConfiguration()->SetFlag(bmdDeckLinkConfig444SDIVideoOutput, output444);
	// If a device without SDI output is used, then SetFlags will return E_NOTIMPL
	if ((result != S_OK) && (result != E_NOTIMPL))
		goto bail;

	// Set the video output mode
	deckLinkOutput = m_selectedDevice->GetDeviceOutput();
	if (deckLinkOutput->EnableVideoOutput(m_selectedDisplayMode->GetDisplayMode(), m_selectedVideoOutputFlags) != S_OK)
		goto bail;

	// Set the audio output mode
	if (deckLinkOutput->EnableAudioOutput(bmdAudioSampleRate48kHz, m_audioSampleDepth, m_audioChannelCount, bmdAudioOutputStreamTimestamped) != S_OK)
		goto bail;
	
	// Set Video, audio and screen preview callbacks with DeckLinkOutputDevice delegate
	deckLinkOutput->SetScheduledFrameCompletionCallback(m_selectedDevice);
	deckLinkOutput->SetAudioCallback(m_selectedDevice);
	deckLinkOutput->SetScreenPreviewCallback(m_previewWindow);

	// Generate one second of audio tone
	m_audioSamplesPerFrame = (unsigned long)((m_audioSampleRate * m_frameDuration) / m_frameTimescale);
	m_audioBufferSampleLength = (unsigned long)((m_framesPerSecond * m_audioSampleRate * m_frameDuration) / m_frameTimescale);
	m_audioBuffer = HeapAlloc(GetProcessHeap(), 0, (m_audioBufferSampleLength * m_audioChannelCount * (m_audioSampleDepth / 8)));
	if (m_audioBuffer == NULL)
		goto bail;
	FillSine(m_audioBuffer, m_audioBufferSampleLength, m_audioChannelCount, m_audioSampleDepth);
	
	// Generate a frame of black
	m_videoFrameBlack = CreateOutputFrame(FillBlack);
	if (! m_videoFrameBlack)
		goto bail;

	// Generate a frame of colour bars
	m_videoFrameBars = CreateOutputFrame(FillColourBars);
	if (! m_videoFrameBars)
		goto bail;

	// Begin video preroll by scheduling a second of frames in hardware
	m_totalFramesScheduled = 0;
	for (unsigned i = 0; i < m_framesPerSecond; i++)
		ScheduleNextFrame(true);
	
	// Begin audio preroll.  This will begin calling our audio callback, which will start the DeckLink output stream.
	m_totalAudioSecondsScheduled = 0;
	if (deckLinkOutput->BeginAudioPreroll() != S_OK)
		goto bail;
	
	EnterCriticalSection(&m_stopPlaybackLock);
	m_scheduledPlaybackStopped = false;
	LeaveCriticalSection(&m_stopPlaybackLock);

	// Success; update the UI
	m_running = true;
	m_startButton.SetWindowText(_T("Stop"));
	// Disable the user interface while running (prevent the user from making changes to the output signal)
	EnableInterface(FALSE);
	
	return;
	
bail:
	// *** Error-handling code.  Cleanup any resources that were allocated. *** //
	StopRunning();
}


void	CSignalGeneratorDlg::StopRunning ()
{
	IDeckLinkOutput* deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	// Stop the audio and video output streams immediately
	deckLinkOutput->StopScheduledPlayback(0, NULL, 0);

	// Recommended to wait for IDeckLinkVideoOutputCallback::ScheduledPlaybackHasStopped callback before disabling output
	EnterCriticalSection(&m_stopPlaybackLock);
	while (!m_scheduledPlaybackStopped)
	{
		SleepConditionVariableCS(&m_stopPlaybackCondition, &m_stopPlaybackLock, INFINITE);
	}
	LeaveCriticalSection(&m_stopPlaybackLock);

	// Dereference DeckLinkOutputDevice delegate from callbacks
	deckLinkOutput->SetScheduledFrameCompletionCallback(NULL);
	deckLinkOutput->SetAudioCallback(NULL);
	deckLinkOutput->SetScreenPreviewCallback(NULL);

	// Disable video and audio outputs
	deckLinkOutput->DisableAudioOutput();
	deckLinkOutput->DisableVideoOutput();

	if (m_videoFrameBlack != NULL)
		m_videoFrameBlack->Release();
	m_videoFrameBlack = NULL;
	
	if (m_videoFrameBars != NULL)
		m_videoFrameBars->Release();
	m_videoFrameBars = NULL;
	
	if (m_audioBuffer != NULL)
		HeapFree(GetProcessHeap(), 0, m_audioBuffer);
	m_audioBuffer = NULL;
	
	// Success; update the UI
	m_running = false;
	m_startButton.SetWindowText(_T("Start"));
	// Re-enable the user interface when stopped
	EnableInterface(TRUE);
}


void	CSignalGeneratorDlg::ScheduleNextFrame (bool prerolling)
{
	IDeckLinkOutput* deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	if (prerolling == false)
	{
		// If not prerolling, make sure that playback is still active
		if (m_running == false)
			return;
	}
	
	if (m_outputSignal == kOutputSignalPip)
	{
		if ((m_totalFramesScheduled % m_framesPerSecond) == 0)
		{
			// On each second, schedule a frame of bars
			if (deckLinkOutput->ScheduleVideoFrame(m_videoFrameBars, (m_totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale) != S_OK)
				return;
		}
		else
		{
			// Schedue frames of black
			if (deckLinkOutput->ScheduleVideoFrame(m_videoFrameBlack, (m_totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale) != S_OK)
				return;
		}
	}
	else
	{
		if ((m_totalFramesScheduled % m_framesPerSecond) == 0)
		{
			// On each second, schedule a frame of black
			if (deckLinkOutput->ScheduleVideoFrame(m_videoFrameBlack, (m_totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale) != S_OK)
				return;
		}
		else
		{
			// Schedue frames of color bars
			if (deckLinkOutput->ScheduleVideoFrame(m_videoFrameBars, (m_totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale) != S_OK)
				return;
		}
	}
	
	m_totalFramesScheduled += 1;
}

void	CSignalGeneratorDlg::WriteNextAudioSamples ()
{
	IDeckLinkOutput* deckLinkOutput = m_selectedDevice->GetDeviceOutput();

	// Write one second of audio to the DeckLink API.
	
	if (m_outputSignal == kOutputSignalPip)
	{
		// Schedule one-frame of audio tone
		if (deckLinkOutput->ScheduleAudioSamples(m_audioBuffer, m_audioSamplesPerFrame, (m_totalAudioSecondsScheduled * m_audioBufferSampleLength), m_audioSampleRate, NULL) != S_OK)
			return;
	}
	else
	{
		// Schedule one-second (minus one frame) of audio tone
		if (deckLinkOutput->ScheduleAudioSamples(m_audioBuffer, (m_audioBufferSampleLength - m_audioSamplesPerFrame), (m_totalAudioSecondsScheduled * m_audioBufferSampleLength) + m_audioSamplesPerFrame, m_audioSampleRate, NULL) != S_OK)
			return;
	}
	
	m_totalAudioSecondsScheduled += 1;
}

void	CSignalGeneratorDlg::ScheduledPlaybackStopped()
{
	// Notify waiting process that scheduled playback has stopped
	EnterCriticalSection(&m_stopPlaybackLock);
	m_scheduledPlaybackStopped = true;
	LeaveCriticalSection(&m_stopPlaybackLock);

	WakeConditionVariable(&m_stopPlaybackCondition);
}

void	CSignalGeneratorDlg::HaltStreams()
{
	// Profile is changing, stop playback if running
	if (m_running)
		StopRunning();
}

LRESULT CSignalGeneratorDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	AddDevice((IDeckLink*)wParam);
	return 0;
}

LRESULT	CSignalGeneratorDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	RemoveDevice((IDeckLink*)wParam);
	return 0;
}

LRESULT	CSignalGeneratorDlg::OnProfileUpdate(WPARAM wParam, LPARAM lParam)
{
	// Update display mode menu with new profile
	RefreshDisplayModeMenu();

	// Update available audio channels with new profile
	RefreshAudioChannelMenu();

	return 0;
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSignalGeneratorDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void CSignalGeneratorDlg::OnClose()
{
	if (m_running)
		StopRunning();

	// Disable profile callback
	if ((m_selectedDevice != NULL) && (m_selectedDevice->GetDeviceProfileManager() != NULL))
	{
		m_selectedDevice->GetDeviceProfileManager()->SetCallback(NULL);
	}

	// Disable DeckLink device discovery
	m_deckLinkDiscovery->disable();

	// Release all DeckLinkOutputDevice instances
	while (m_deviceListCombo.GetCount() > 0)
	{
		DeckLinkOutputDevice* device = (DeckLinkOutputDevice*)m_deviceListCombo.GetItemDataPtr(0);
		device->Release();
		m_deviceListCombo.DeleteString(0);
	}

	// Release all DisplayMode instances
	while (m_videoFormatCombo.GetCount() > 0)
	{
		IDeckLinkDisplayMode* deckLinkDisplayMode = (IDeckLinkDisplayMode*)m_videoFormatCombo.GetItemDataPtr(0);
		deckLinkDisplayMode->Release();
		m_videoFormatCombo.DeleteString(0);
	}

	// Release Profile Callback
	if (m_profileCallback != NULL)
	{
		m_profileCallback->Release();
	}

	// Release PreviewWindow instance
	if (m_previewWindow != NULL)
	{
		m_previewWindow->Release();
	}

	// Release DeckLinkDeviceDiscovery instance
	if (m_deckLinkDiscovery != NULL)
	{
		m_deckLinkDiscovery->Release();
	}

	DeleteCriticalSection(&m_stopPlaybackLock);

	CDialog::OnClose();
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSignalGeneratorDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



/*****************************************/


void	FillSine (void* audioBuffer, unsigned long samplesToWrite, unsigned long channels, unsigned long sampleDepth)
{
	if (sampleDepth == 16)
	{
		INT16*		nextBuffer;
		
		nextBuffer = (INT16*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			INT16		sample;
			
			sample = (INT16)(24576.0 * sin((i * 2.0 * M_PI) / 48.0));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
	else if (sampleDepth == 32)
	{
		INT32*		nextBuffer;
		
		nextBuffer = (INT32*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			INT32		sample;
			
			sample = (INT32)(1610612736.0 * sin((i * 2.0 * M_PI) / 48.0));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
}

void	FillColourBars (IDeckLinkVideoFrame* theFrame, bool reversed)
{
	DWORD*			nextWord;
	unsigned long	width;
	unsigned long	height;
	DWORD*			bars;
	unsigned long	colourBarCount;
	
	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();
	
	if (width > 720)
	{
		bars = gHD75pcColourBars;
		colourBarCount = sizeof(gHD75pcColourBars) / sizeof(gHD75pcColourBars[0]);
	}
	else
	{
		bars = gSD75pcColourBars;
		colourBarCount = sizeof(gSD75pcColourBars) / sizeof(gSD75pcColourBars[0]);
	}

	for (unsigned y = 0; y < height; y++)
	{
		for (unsigned x = 0; x < width; x+=2)
		{
			int pos = x * colourBarCount / width;

			if (reversed)
				pos = colourBarCount - pos - 1;

			*(nextWord++) = bars[pos];
		}
	}
}

void	FillBlack (IDeckLinkVideoFrame* theFrame, bool /* unused */ )
{
	DWORD*			nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned long	wordsRemaining;
	
	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();
	
	wordsRemaining = (width*2 * height) / 4;
	
	while (wordsRemaining-- > 0)
		*(nextWord++) = 0x10801080;
}

