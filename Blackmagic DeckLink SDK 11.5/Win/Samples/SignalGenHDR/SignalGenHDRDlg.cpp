/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// SignalGenHDRDlg.cpp : implementation file
//

#include "stdafx.h"
#include <utility>
#include <vector>

#include "ColorBars.h"
#include "HDRVideoFrame.h"
#include "SignalGenHDR.h"
#include "SignalGenHDRDlg.h"


// Define conventional display primaries and reference white for colorspace
static const ChromaticityCoordinates kDefaultRec2020Colorimetrics		= { 0.708, 0.292, 0.170, 0.797, 0.131, 0.046, 0.3127, 0.3290 };
static const double kDefaultMaxDisplayMasteringLuminance	= 1000.0;
static const double kDefaultMinDisplayMasteringLuminance	= 0.0001;
static const double kDefaultMaxCLL							= 1000.0;
static const double kDefaultMaxFALL							= 50.0;

// Supported pixel formats map to string representation and boolean if RGB format
static const std::map<BMDPixelFormat, std::pair<CString, BOOL>> kPixelFormats = {
	std::make_pair(bmdFormat10BitYUV,	std::make_pair(_T("10-bit YUV (Video-range)"), FALSE)),
	std::make_pair(bmdFormat10BitRGB,	std::make_pair(_T("10-bit RGB (Video-range)"), TRUE)),
	std::make_pair(bmdFormat12BitRGBLE, std::make_pair(_T("12-bit RGB (Full-range)"), TRUE)),
};

// Supported EOTFs
static const std::vector<std::pair<EOTF, CString>> kSupportedEOTF = {
	std::make_pair(EOTF::PQ,	_T("PQ (ST 2084)")),
	std::make_pair(EOTF::HLG,	_T("HLG")),
};

CSignalGenHDRDlg::CSignalGenHDRDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSignalGenHDRDlg::IDD, pParent), m_running(false), m_videoFrameBars(nullptr)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CSignalGenHDRDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDOK, m_startButton);
	DDX_Control(pDX, IDC_COMBO_DEVICE, m_deviceListCombo);
	DDX_Control(pDX, IDC_COMBO_VIDEO_FORMAT, m_videoFormatCombo);
	DDX_Control(pDX, IDC_COMBO_PIXEL_FORMAT, m_pixelFormatCombo);
	DDX_Control(pDX, IDC_PREVIEW_BOX, m_previewBox);
	DDX_Control(pDX, IDC_COMBO_EOTF, m_eotfCombo);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_RED_X, m_displayPrimaryRedXSlider);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_RED_Y, m_displayPrimaryRedYSlider);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_GREEN_X, m_displayPrimaryGreenXSlider);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_GREEN_Y, m_displayPrimaryGreenYSlider);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_BLUE_X, m_displayPrimaryBlueXSlider);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_PRIMARY_BLUE_Y, m_displayPrimaryBlueYSlider);
	DDX_Control(pDX, IDC_SLIDER_WHITE_POINT_X, m_whitePointXSlider);
	DDX_Control(pDX, IDC_SLIDER_WHITE_POINT_Y, m_whitePointYSlider);
	DDX_Control(pDX, IDC_SLIDER_MAX_DISPLAY_MASTERING_LUMA, m_maxDisplayMasteringLuminanceSlider);
	DDX_Control(pDX, IDC_SLIDER_MIN_DISPLAY_MASTERING_LUMA, m_minDisplayMasteringLuminanceSlider);
	DDX_Control(pDX, IDC_SLIDER_MAX_FALL, m_maxFALLSlider);
	DDX_Control(pDX, IDC_SLIDER_MAX_CLL, m_maxCLLSlider);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_RED_X, m_displayPrimaryRedXEdit);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_RED_Y, m_displayPrimaryRedYEdit);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_GREEN_X, m_displayPrimaryGreenXEdit);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_GREEN_Y, m_displayPrimaryGreenYEdit);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_BLUE_X, m_displayPrimaryBlueXEdit);
	DDX_Control(pDX, IDC_EDIT_DISPLAY_PRIMARY_BLUE_Y, m_displayPrimaryBlueYEdit);
	DDX_Control(pDX, IDC_EDIT_WHITE_POINT_X, m_whitePointXEdit);
	DDX_Control(pDX, IDC_EDIT_WHITE_POINT_Y, m_whitePointYEdit);
	DDX_Control(pDX, IDC_EDIT_MAX_DISPLAY_MASTERING_LUMINANCE, m_maxDisplayMasteringLuminanceEdit);
	DDX_Control(pDX, IDC_EDIT_MIN_DISPLAY_MASTERING_LUMINANCE, m_minDisplayMasteringLuminanceEdit);
	DDX_Control(pDX, IDC_EDIT_MAX_FALL, m_maxFALLEdit);
	DDX_Control(pDX, IDC_EDIT_MAX_CLL, m_maxCLLEdit);
}

BEGIN_MESSAGE_MAP(CSignalGenHDRDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDOK, &CSignalGenHDRDlg::OnBnClickedOk)
	ON_CBN_SELCHANGE(IDC_COMBO_DEVICE, &CSignalGenHDRDlg::OnNewDeviceSelected)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CSignalGenHDRDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CSignalGenHDRDlg::OnRemoveDevice)
	ON_CBN_SELCHANGE(IDC_COMBO_VIDEO_FORMAT, &CSignalGenHDRDlg::OnNewVideoFormatSelected)
	ON_CBN_SELCHANGE(IDC_COMBO_PIXEL_FORMAT, &CSignalGenHDRDlg::OnNewPixelFormatSelected)
	ON_CBN_SELCHANGE(IDC_COMBO_EOTF, &CSignalGenHDRDlg::OnNewEOTFSelected)
	ON_WM_HSCROLL()
	ON_WM_CLOSE()
END_MESSAGE_MAP()


void CSignalGenHDRDlg::RefreshDisplayModeMenu(void)
{
	// Populate the display mode combo with a list of display modes supported by the installed DeckLink card
	CComPtr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	CComPtr<IDeckLinkDisplayMode>			deckLinkDisplayMode;

	// Release existing Display Mode references and clear combo box 
	m_supportedDisplayModeMap.clear();
	m_videoFormatCombo.ResetContent();

	if (m_selectedDeckLinkOutput->GetDisplayModeIterator(&displayModeIterator) != S_OK)
		return;
	
	while (displayModeIterator->Next(&deckLinkDisplayMode) == S_OK)
	{
		CComBSTR				modeName;
		int						newIndex;
		BMDDisplayMode			displayMode;

		if (deckLinkDisplayMode->GetName(&modeName) != S_OK)
		{
			deckLinkDisplayMode = nullptr;
			continue;
		}

		// Ignore NTSC/PAL/720p/1080i display modes
		if ((deckLinkDisplayMode->GetWidth() < 1920) || (deckLinkDisplayMode->GetFieldDominance() != bmdProgressiveFrame))
		{
			deckLinkDisplayMode = nullptr;
			continue;
		}
		
		displayMode = deckLinkDisplayMode->GetDisplayMode();
		m_supportedDisplayModeMap[displayMode] = deckLinkDisplayMode;

		CString modeNameCString(modeName);
		newIndex = m_videoFormatCombo.AddString(modeNameCString);
		m_videoFormatCombo.SetItemData(newIndex, displayMode);

		if (m_videoFormatCombo.GetCount() == 1)
		{
			// We have added our first item, refresh pixel format menu
			m_videoFormatCombo.SetCurSel(0);
			OnNewVideoFormatSelected();
		}

		deckLinkDisplayMode.Release();
	}
}

void CSignalGenHDRDlg::RefreshPixelFormatMenu(void)
{
	// Populate the pixel format mode combo with a list of pixel formats supported by the installed DeckLink card
	m_pixelFormatCombo.ResetContent();

	for (auto& pixelFormat : kPixelFormats)
	{
		HRESULT		hr;
		int			newIndex;
		BOOL		displayModeSupport = FALSE;
		CString		pixelFormatString;

		std::tie(pixelFormatString, std::ignore) = pixelFormat.second;

		hr = m_selectedDeckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, m_selectedDisplayMode->GetDisplayMode(), pixelFormat.first, bmdNoVideoOutputConversion, bmdSupportedVideoModeDefault, nullptr, &displayModeSupport);
		if (hr != S_OK || !displayModeSupport)
			continue;

		newIndex = m_pixelFormatCombo.AddString(pixelFormatString);
		m_pixelFormatCombo.SetItemData(newIndex, pixelFormat.first);
	}

	m_pixelFormatCombo.SetCurSel(0);
	OnNewPixelFormatSelected();
}

void CSignalGenHDRDlg::RefreshEOTFMenu(void)
{
	m_eotfCombo.ResetContent();

	for (auto& eotf : kSupportedEOTF)
	{
		// Full-range not defined for HLG EOTF
		if ((eotf.first == EOTF::HLG) && (m_selectedPixelFormat == bmdFormat12BitRGBLE))
			continue;

		int newIndex = m_eotfCombo.AddString(eotf.second);
		m_eotfCombo.SetItemData(newIndex, static_cast<int64_t>(eotf.first));
	}

	m_eotfCombo.SetCurSel(0);
	OnNewEOTFSelected();
}

// CSignalGenHDRDlg message handlers

BOOL CSignalGenHDRDlg::OnInitDialog()
{
	bool		success = false;
	CString		editStr;
	
	CDialog::OnInitDialog();

	EnableInterface(false);
	EnableHDRInterface(false);

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	m_selectedHDRParameters.EOTF = static_cast<int64_t>(EOTF::PQ);
	m_selectedHDRParameters.referencePrimaries = kDefaultRec2020Colorimetrics;
	m_selectedHDRParameters.maxDisplayMasteringLuminance = kDefaultMaxDisplayMasteringLuminance;
	m_selectedHDRParameters.minDisplayMasteringLuminance = kDefaultMinDisplayMasteringLuminance;
	m_selectedHDRParameters.maxCLL = kDefaultMaxCLL;
	m_selectedHDRParameters.maxFALL = kDefaultMaxFALL;

	// Select the first item in each combo box
	m_pixelFormatCombo.SetCurSel(0);
	m_eotfCombo.SetCurSel(0);

	// Set range of sliders
	m_displayPrimaryRedXSlider.SetRange(0, 1000);
	m_displayPrimaryRedYSlider.SetRange(0, 1000);
	m_displayPrimaryGreenXSlider.SetRange(0, 1000);
	m_displayPrimaryGreenYSlider.SetRange(0, 1000);
	m_displayPrimaryBlueXSlider.SetRange(0, 1000);
	m_displayPrimaryBlueYSlider.SetRange(0, 1000);
	m_whitePointXSlider.SetRange(0, 10000);
	m_whitePointYSlider.SetRange(0, 10000);
	m_maxDisplayMasteringLuminanceSlider.SetRange(0, 40000);
	m_minDisplayMasteringLuminanceSlider.SetRange(-40000, 0);
	m_maxFALLSlider.SetRange(0, 40000);
	m_maxCLLSlider.SetRange(0, 40000);

	m_displayPrimaryRedXSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.RedX * 1000));
	m_displayPrimaryRedYSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.RedY * 1000));
	m_displayPrimaryGreenXSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.GreenX * 1000));
	m_displayPrimaryGreenYSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.GreenY * 1000));
	m_displayPrimaryBlueXSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.BlueX * 1000));
	m_displayPrimaryBlueYSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.BlueY * 1000));
	m_whitePointXSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.WhiteX * 10000));
	m_whitePointYSlider.SetPos((int)(m_selectedHDRParameters.referencePrimaries.WhiteY * 10000));
	m_maxDisplayMasteringLuminanceSlider.SetPos((int)(log10(m_selectedHDRParameters.maxDisplayMasteringLuminance) * 10000));
	m_minDisplayMasteringLuminanceSlider.SetPos((int)(log10(m_selectedHDRParameters.minDisplayMasteringLuminance) * 10000));
	m_maxCLLSlider.SetPos((int)(log10(m_selectedHDRParameters.maxCLL) * 10000));
	m_maxFALLSlider.SetPos((int)(log10(m_selectedHDRParameters.maxFALL) * 10000));

	UpdateSliderValues();

	//
	// Create and initialise DeckLink device discovery and preview objects
	m_deckLinkDiscovery.Attach(new DeckLinkDeviceDiscovery(this));
	if (m_deckLinkDiscovery != nullptr)
	{
		if (!m_deckLinkDiscovery->enable())
		{
			MessageBox(_T("This application requires the DeckLink drivers installed.\nPlease install the Blackmagic DeckLink drivers to use the features of this application."), _T("Error"));
			goto bail;
		}
	}

	m_previewWindow.Attach(new PreviewWindow());
	if (m_previewWindow != nullptr)
	{
		if (m_previewWindow->init(&m_previewBox) == false)
		{
			MessageBox(_T("This application was unable to initialise the preview window"), _T("Error"));
		}
	}
bail: 
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSignalGenHDRDlg::OnBnClickedOk()
{
	if (m_running == false)
		StartRunning();
	else
		StopRunning();
}

void CSignalGenHDRDlg::OnNewDeviceSelected()
{
	int						selectedDeviceIndex;
	CComPtr<IDeckLink>		selectedDeckLink;

	selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	m_selectedDeckLinkOutput.Release();

	selectedDeckLink = (IDeckLink*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex);

	// Get output interface
	m_selectedDeckLinkOutput = selectedDeckLink;
	if (!m_selectedDeckLinkOutput)
		return;

	// Get configuration interface
	m_selectedDeckLinkConfiguration = selectedDeckLink;
	if (!m_selectedDeckLinkConfiguration)
		return;

	// Update the video mode popup menu
	RefreshDisplayModeMenu();
}


void CSignalGenHDRDlg::OnNewVideoFormatSelected()
{
	int			selectedVideoFormatIndex;
	CString		videoFormatName;

	selectedVideoFormatIndex = m_videoFormatCombo.GetCurSel();
	if (selectedVideoFormatIndex < 0)
		return;

	auto iter = m_supportedDisplayModeMap.find((BMDDisplayMode)m_videoFormatCombo.GetItemData(selectedVideoFormatIndex));
	if (iter == m_supportedDisplayModeMap.end())
		return;

	m_selectedDisplayMode = iter->second;

	RefreshPixelFormatMenu();
}

void CSignalGenHDRDlg::OnNewPixelFormatSelected()
{
	m_selectedPixelFormat = (BMDPixelFormat)m_pixelFormatCombo.GetItemData(m_pixelFormatCombo.GetCurSel());
	RefreshEOTFMenu();
}

void CSignalGenHDRDlg::OnNewEOTFSelected()
{
	m_selectedHDRParameters.EOTF = m_eotfCombo.GetItemData(m_eotfCombo.GetCurSel());
	EnableHDRInterface(true);
	UpdateOutputFrame();
}

void CSignalGenHDRDlg::AddDevice(CComPtr<IDeckLink> deckLink)
{
	int										deviceIndex;
	CComBSTR								deviceNameBSTR;
	CString									deviceName;
	CComQIPtr<IDeckLinkProfileAttributes>	deckLinkAttributes;
	int64_t									intAttribute;
	BOOL									attributeFlag;

	deckLinkAttributes = deckLink;
	if (!deckLinkAttributes)
		return;

	// Check that device has playback interface
	if ((deckLinkAttributes->GetInt(BMDDeckLinkVideoIOSupport, &intAttribute) != S_OK)
		|| ((intAttribute & bmdDeviceSupportsPlayback) == 0))
		return;

	// Check that device supports HDR metadata and Rec2020
	if ((deckLinkAttributes->GetFlag(BMDDeckLinkSupportsHDRMetadata, &attributeFlag) != S_OK)
		|| !attributeFlag)
		return;
	if ((deckLinkAttributes->GetFlag(BMDDeckLinkSupportsColorspaceMetadata, &attributeFlag) != S_OK)
		|| !attributeFlag)
		return;

	// Get device name
	if (deckLink->GetDisplayName(&deviceNameBSTR) == S_OK)
	{
		deviceName = CString(deviceNameBSTR);
	}
	else
	{
		deviceName = _T("DeckLink");
	}

	// Add this DeckLink device to the device list
	deviceIndex = m_deviceListCombo.AddString(deviceName);
	m_deviceListCombo.SetItemDataPtr(deviceIndex, (void*)deckLink.Detach());

	if (m_deviceListCombo.GetCount() == 1)
	{
		// We have added our first item, refresh and enable UI
		m_deviceListCombo.SetCurSel(0);
		OnNewDeviceSelected();

		m_startButton.EnableWindow(true);
		EnableInterface(true);
		EnableHDRInterface(true);
	}
}

void CSignalGenHDRDlg::RemoveDevice(CComPtr<IDeckLink> deckLink)
{
	CComPtr<IDeckLink>	deviceToRemove;
	bool				removeSelectedDevice = false;

	// Find the combo box entry to remove (there may be multiple entries with the same name, but each
	// will have a different data pointer).
	for (int i = 0; i < m_deviceListCombo.GetCount(); ++i)
	{
		if (deckLink == (IDeckLink*)m_deviceListCombo.GetItemDataPtr(i))
		{
			// Check whether item to remove is selected device
			if (i == m_deviceListCombo.GetCurSel())
				removeSelectedDevice = true;

			deviceToRemove = deckLink;
			m_deviceListCombo.DeleteString(i);
			break;
		}
	}

	if (deviceToRemove == nullptr)
		return;

	if (removeSelectedDevice)
	{
		// Device to removed is selected device
		// If playback is active, stop it
		if (m_running)
			StopRunning();

		// Select the first device in the list and enable the interface
		if (m_deviceListCombo.GetCount() > 0)
		{
			m_deviceListCombo.SetCurSel(0);
			OnNewDeviceSelected();
			EnableInterface(true);
		}
	}

	if (m_deviceListCombo.GetCount() == 0)
	{
		// Last device removed, disable interface
		m_startButton.EnableWindow(false);
		EnableInterface(false);
		EnableHDRInterface(false);
	}
}

void CSignalGenHDRDlg::EnableInterface(bool enable)
{
	// Set the enable state of user interface elements
	m_deviceListCombo.EnableWindow(enable);
	m_videoFormatCombo.EnableWindow(enable);
	m_pixelFormatCombo.EnableWindow(enable);
}

void CSignalGenHDRDlg::EnableHDRInterface(bool enable)
{
	bool enableMetadata = enable && (m_eotfCombo.GetItemData(m_eotfCombo.GetCurSel()) != static_cast<int64_t>(EOTF::HLG));

	m_eotfCombo.EnableWindow(enable);

	m_displayPrimaryRedXSlider.EnableWindow(enableMetadata);
	m_displayPrimaryRedYSlider.EnableWindow(enableMetadata);
	m_displayPrimaryGreenXSlider.EnableWindow(enableMetadata);
	m_displayPrimaryGreenYSlider.EnableWindow(enableMetadata);
	m_displayPrimaryBlueXSlider.EnableWindow(enableMetadata);
	m_displayPrimaryBlueYSlider.EnableWindow(enableMetadata);
	m_whitePointXSlider.EnableWindow(enableMetadata);
	m_whitePointYSlider.EnableWindow(enableMetadata);
	m_maxDisplayMasteringLuminanceSlider.EnableWindow(enableMetadata);
	m_minDisplayMasteringLuminanceSlider.EnableWindow(enableMetadata);
	m_maxFALLSlider.EnableWindow(enableMetadata);
	m_maxCLLSlider.EnableWindow(enableMetadata);

	m_displayPrimaryRedXEdit.EnableWindow(enableMetadata);
	m_displayPrimaryRedYEdit.EnableWindow(enableMetadata);
	m_displayPrimaryGreenXEdit.EnableWindow(enableMetadata);
	m_displayPrimaryGreenYEdit.EnableWindow(enableMetadata);
	m_displayPrimaryBlueXEdit.EnableWindow(enableMetadata);
	m_displayPrimaryBlueYEdit.EnableWindow(enableMetadata);
	m_whitePointXEdit.EnableWindow(enableMetadata);
	m_whitePointYEdit.EnableWindow(enableMetadata);
	m_maxDisplayMasteringLuminanceEdit.EnableWindow(enableMetadata);
	m_minDisplayMasteringLuminanceEdit.EnableWindow(enableMetadata);
	m_maxFALLEdit.EnableWindow(enableMetadata);
	m_maxCLLEdit.EnableWindow(enableMetadata);
}

HRESULT CSignalGenHDRDlg::CreateColorbarsFrame()
{
	CComPtr<IDeckLinkMutableVideoFrame>	referenceFrame;
	CComPtr<IDeckLinkMutableVideoFrame>	scheduleFrame;
	BMDPixelFormat						referencePixelFormat;
	int									referenceFrameBytesPerRow;
	CComPtr<IDeckLinkVideoConversion>	frameConverter;
	unsigned long						frameWidth;
	unsigned long						frameHeight;
	EOTFColorRange						colorRange;
	HRESULT								hr = S_OK;
	
	frameWidth = m_selectedDisplayMode->GetWidth();
	frameHeight = m_selectedDisplayMode->GetHeight();

	// Generate reference frame
	referencePixelFormat = (m_selectedPixelFormat == bmdFormat12BitRGBLE) ? bmdFormat12BitRGBLE : bmdFormat10BitRGB;
	referenceFrameBytesPerRow = GetBytesPerRow(referencePixelFormat, frameWidth);
	hr = m_selectedDeckLinkOutput->CreateVideoFrame(frameWidth, frameHeight, referenceFrameBytesPerRow, referencePixelFormat, bmdFrameFlagDefault, &referenceFrame);
	if (hr != S_OK)
		return hr;

	if (m_selectedHDRParameters.EOTF == static_cast<int64_t>(EOTF::HLG))
		colorRange = EOTFColorRange::HLGVideoRange;
	else if (m_selectedPixelFormat == bmdFormat12BitRGBLE)
		colorRange = EOTFColorRange::PQFullRange;
	else
		colorRange = EOTFColorRange::PQVideoRange;

	// Fill frame with BT.2111 colorbars
	FillBT2111ColorBars(referenceFrame, colorRange);

	if (m_selectedPixelFormat == referencePixelFormat)
	{
		// Reference frame is in requested pixel format - conversion not required
		scheduleFrame = referenceFrame;
	}
	else
	{
		int scheduleFrameBytesPerRow = GetBytesPerRow(m_selectedPixelFormat, frameWidth);

		hr = frameConverter.CoCreateInstance(CLSID_CDeckLinkVideoConversion, nullptr, CLSCTX_ALL);
		if (hr != S_OK)
			return hr;

		hr = m_selectedDeckLinkOutput->CreateVideoFrame(frameWidth, frameHeight, scheduleFrameBytesPerRow, m_selectedPixelFormat, bmdFrameFlagDefault, &scheduleFrame);
		if (hr != S_OK)
			return hr;

		hr = frameConverter->ConvertFrame(referenceFrame, scheduleFrame);
		if (hr != S_OK)
			return hr;
	}

	m_videoFrameBars.Attach(new HDRVideoFrame(scheduleFrame, m_selectedHDRParameters));

	return hr;
}

void CSignalGenHDRDlg::StartRunning()
{
	BOOL		output444;
	HRESULT		result;

	// Set the output to 444 if RGB mode is selected
	try
	{
		std::tie(std::ignore, output444) = kPixelFormats.at(m_selectedPixelFormat);
	}
	catch (std::out_of_range)
	{
		goto bail;
	}

	result = m_selectedDeckLinkConfiguration->SetFlag(bmdDeckLinkConfig444SDIVideoOutput, output444);
	// If a device without SDI output is used, then SetFlags will return E_NOTIMPL
	if ((result != S_OK) && (result != E_NOTIMPL))
		goto bail;

	// Set the video output mode
	if (m_selectedDeckLinkOutput->EnableVideoOutput(m_selectedDisplayMode->GetDisplayMode(), bmdVideoOutputFlagDefault) != S_OK)
		goto bail;

	// Set screen preview callbacks with UI delegate
	if (m_selectedDeckLinkOutput->SetScreenPreviewCallback(m_previewWindow) != S_OK)
		goto bail;

	// Generate a frame of colour bars
	if (CreateColorbarsFrame() != S_OK)
		goto bail;

	if (m_selectedDeckLinkOutput->DisplayVideoFrameSync(m_videoFrameBars) != S_OK)
		goto bail;

	// Success; update the UI
	m_running = true;
	m_startButton.SetWindowText(_T("Stop"));
	// Disable the user interface while running (prevent the user from making changes to the output signal)
	EnableInterface(false);
	
	return;
	
bail:
	// *** Error-handling code.  Cleanup any resources that were allocated. *** //
	StopRunning();
}

void CSignalGenHDRDlg::StopRunning()
{
	// Disable video output interface
	if (m_selectedDeckLinkOutput != nullptr)
	{
		m_selectedDeckLinkOutput->SetScreenPreviewCallback(nullptr);
		m_selectedDeckLinkOutput->DisableVideoOutput();
	}

	m_videoFrameBars.Release();
	
	// Success; update the UI
	m_running = false;
	m_startButton.SetWindowText(_T("Start"));
	// Re-enable the user interface when stopped
	EnableInterface(true);
}

LRESULT CSignalGenHDRDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	AddDevice(deckLink);
	return 0;
}

LRESULT	CSignalGenHDRDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	RemoveDevice(deckLink);
	return 0;
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSignalGenHDRDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void CSignalGenHDRDlg::OnClose()
{
	if (m_running)
		StopRunning();

	for (int i = 0; i < m_deviceListCombo.GetCount(); i++)
	{
		CComPtr<IDeckLink> deckLink;
		deckLink.Attach((IDeckLink*)m_deviceListCombo.GetItemDataPtr(i));
		deckLink.Release();
	}
	
	// Disable DeckLink device discovery
	m_deckLinkDiscovery->disable();
	m_deckLinkDiscovery.Release();

	// Release supported display modes 
	m_supportedDisplayModeMap.clear();

	// Release preview window
	m_previewWindow.Release();

	CDialog::OnClose();
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSignalGenHDRDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CSignalGenHDRDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CSliderCtrl* slider = reinterpret_cast<CSliderCtrl*>(pScrollBar);
	CString editStr;

	int sliderID = slider->GetDlgCtrlID();
	int newPos = slider->GetPos();

	switch (sliderID)
	{
		case IDC_SLIDER_DISPLAY_PRIMARY_RED_X:
			m_selectedHDRParameters.referencePrimaries.RedX = (double)newPos / 1000;
			break;

		case IDC_SLIDER_DISPLAY_PRIMARY_RED_Y:
			m_selectedHDRParameters.referencePrimaries.RedY = (double)newPos / 1000;
			break;

		case IDC_SLIDER_DISPLAY_PRIMARY_GREEN_X:
			m_selectedHDRParameters.referencePrimaries.GreenX = (double)newPos / 1000;
			break;

		case IDC_SLIDER_DISPLAY_PRIMARY_GREEN_Y:
			m_selectedHDRParameters.referencePrimaries.GreenY = (double)newPos / 1000;
			break;

		case IDC_SLIDER_DISPLAY_PRIMARY_BLUE_X:
			m_selectedHDRParameters.referencePrimaries.BlueX = (double)newPos / 1000;
			break;

		case IDC_SLIDER_DISPLAY_PRIMARY_BLUE_Y:
			m_selectedHDRParameters.referencePrimaries.BlueY = (double)newPos / 1000;
			break;

		case IDC_SLIDER_WHITE_POINT_X:
			m_selectedHDRParameters.referencePrimaries.WhiteX = (double)newPos / 10000;
			break;
			
		case IDC_SLIDER_WHITE_POINT_Y:
			m_selectedHDRParameters.referencePrimaries.WhiteY = (double)newPos / 10000;
			break;

		case IDC_SLIDER_MAX_DISPLAY_MASTERING_LUMA:
			m_selectedHDRParameters.maxDisplayMasteringLuminance = pow(10.0, ((double)newPos / 10000));
			break;

		case IDC_SLIDER_MIN_DISPLAY_MASTERING_LUMA:
			m_selectedHDRParameters.minDisplayMasteringLuminance = pow(10.0, ((double)newPos / 10000));
			break;

		case IDC_SLIDER_MAX_CLL:
			m_selectedHDRParameters.maxCLL = pow(10.0, ((double)newPos / 10000));
			break;

		case IDC_SLIDER_MAX_FALL:
			m_selectedHDRParameters.maxFALL = pow(10.0, ((double)newPos / 10000));
			break;

		default:
			break;
	}

	UpdateSliderValues();

	UpdateOutputFrame();

	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}


void CSignalGenHDRDlg::UpdateSliderValues()
{
	CString editStr;
	
	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.RedX);
	m_displayPrimaryRedXEdit.SetWindowText(editStr);

	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.RedY);
	m_displayPrimaryRedYEdit.SetWindowText(editStr);

	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.GreenX);
	m_displayPrimaryGreenXEdit.SetWindowText(editStr);

	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.GreenY);
	m_displayPrimaryGreenYEdit.SetWindowText(editStr);

	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.BlueX);
	m_displayPrimaryBlueXEdit.SetWindowText(editStr);

	editStr.Format(_T("%.3f"), m_selectedHDRParameters.referencePrimaries.BlueY);
	m_displayPrimaryBlueYEdit.SetWindowText(editStr);

	editStr.Format(_T("%.4f"), m_selectedHDRParameters.referencePrimaries.WhiteX);
	m_whitePointXEdit.SetWindowText(editStr);

	editStr.Format(_T("%.4f"), m_selectedHDRParameters.referencePrimaries.WhiteY);
	m_whitePointYEdit.SetWindowText(editStr);

	editStr.Format(_T("%.f"), m_selectedHDRParameters.maxDisplayMasteringLuminance);
	m_maxDisplayMasteringLuminanceEdit.SetWindowText(editStr);

	editStr.Format(_T("%.4f"), m_selectedHDRParameters.minDisplayMasteringLuminance);
	m_minDisplayMasteringLuminanceEdit.SetWindowText(editStr);

	editStr.Format(_T("%.f"), m_selectedHDRParameters.maxFALL);
	m_maxFALLEdit.SetWindowText(editStr);

	editStr.Format(_T("%.f"), m_selectedHDRParameters.maxCLL);
	m_maxCLLEdit.SetWindowText(editStr);

	UpdateData(FALSE);
}

void CSignalGenHDRDlg::UpdateOutputFrame()
{
	if (m_running)
	{
		// Update the HDR metadata in frame and output
		// As these statements are sequential, they are thread safe.  It is not recommended 
		// that an active frame is updated, and normally synchronization will be required
		m_videoFrameBars->UpdateHDRMetadata(m_selectedHDRParameters);
		m_selectedDeckLinkOutput->DisplayVideoFrameSync(m_videoFrameBars);
	}
}

static int GetBytesPerRow(BMDPixelFormat pixelFormat, ULONG frameWidth)
{
	int bytesPerRow;

	// Refer to DeckLink SDK Manual - 2.7.4 Pixel Formats
	switch (pixelFormat)
	{
	case bmdFormat12BitRGBLE:
		bytesPerRow = (frameWidth * 36) / 8;
		break;

	case bmdFormat10BitYUV:
		bytesPerRow = ((frameWidth + 47) / 48) * 128;
		break;

	case bmdFormat10BitRGB:
		bytesPerRow = ((frameWidth + 63) / 64) * 256;

	default:
		bytesPerRow = frameWidth * 4;
		break;
	}

	return bytesPerRow;
}
