/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/

#include "stdafx.h"
#include <array>
#include <map>
#include <utility>
#include "SignalGenerator.h"
#include "SignalGeneratorDlg.h"
#include "PreviewWindow.h"
#include "ProfileCallback.h"
#include "DeckLinkOutputDevice.h"
#include "DeckLinkDeviceDiscovery.h"
#define _USE_MATH_DEFINES
#include <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// SD 75% Colour Bars
static const std::array<DWORD, 8> gSD75pcColourBars =
{
	0xeb80eb80, 0xa28ea22c, 0x832c839c, 0x703a7048,
	0x54c654b8, 0x41d44164, 0x237223d4, 0x10801080
};

// HD 75% Colour Bars
static const std::array<DWORD, 8> gHD75pcColourBars =
{
	0xeb80eb80, 0xa888a82c, 0x912c9193, 0x8534853f,
	0x3fcc3fc1, 0x33d4336d, 0x1c781cd4, 0x10801080
};

// Supported number audio channels
static const std::array<int, 5> gAudioChannels = { 2, 8, 16, 32, 64 };

// Supported pixel formats map to string represenatation and boolean if RGB format
static const std::map<BMDPixelFormat, std::pair<CString, BOOL>> kPixelFormats = {
	std::make_pair(bmdFormat8BitYUV,	std::make_pair(_T("8-bit YUV"), FALSE)),
	std::make_pair(bmdFormat10BitYUV,	std::make_pair(_T("10-bit YUV"), FALSE)),
	std::make_pair(bmdFormat8BitARGB,	std::make_pair(_T("8-bit RGB"), TRUE)),
	std::make_pair(bmdFormat10BitRGB,	std::make_pair(_T("10-bit RGB"), TRUE)),
};

// Constants for calculating audio tone
static const double kReferenceSoundPressure = 20.0; // dB
static const double kReferenceAudioToneLevel = -20.0; // dB
static const int kReferenceAudioToneFreq = 1000; // Hz

CSignalGeneratorDlg::CSignalGeneratorDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSignalGeneratorDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	
	// Initialize instance variables
	m_running = false;
	m_scheduledPlaybackStopped = false;
	
	m_selectedDisplayMode = bmdModeUnknown;
	m_selectedVideoOutputFlags = bmdVideoOutputFlagDefault;
	m_timeCodeFormat = bmdTimecodeRP188VITC1;
	m_dropFrames = 0;
	m_hfrtcSupported = FALSE;
}

void CSignalGeneratorDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDOK, m_startButton);
	DDX_Control(pDX, IDC_COMBO_DEVICE, m_deviceListCombo);
	DDX_Control(pDX, IDC_COMBO_SIGNAL, m_outputSignalCombo);
	DDX_Control(pDX, IDC_COMBO_CHANNELS, m_audioChannelCombo);
	DDX_Control(pDX, IDC_COMBO_AUDIO_DEPTH, m_audioSampleDepthCombo);
	DDX_Control(pDX, IDC_COMBO_VIDEO_FORMAT, m_videoFormatCombo);
	DDX_Control(pDX, IDC_COMBO_PIXEL_FORMAT, m_pixelFormatCombo);
	DDX_Control(pDX, IDC_PREVIEW_BOX, m_previewBox);
}

BEGIN_MESSAGE_MAP(CSignalGeneratorDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_GETMINMAXINFO()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDOK, &CSignalGeneratorDlg::OnBnClickedOk)
	ON_CBN_SELCHANGE(IDC_COMBO_DEVICE, &CSignalGeneratorDlg::OnNewDeviceSelected)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CSignalGeneratorDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CSignalGeneratorDlg::OnRemoveDevice)
	ON_MESSAGE(WM_UPDATE_PROFILE_MESSAGE, &CSignalGeneratorDlg::OnProfileUpdate)
	ON_WM_CLOSE()
	ON_CBN_SELCHANGE(IDC_COMBO_VIDEO_FORMAT, &CSignalGeneratorDlg::OnNewVideoFormatSelected)
END_MESSAGE_MAP()


void CSignalGeneratorDlg::RefreshOutputDeviceList(void)
{
	int index;
	BOOL hasActiveOutputDevices;

	m_deviceListCombo.ResetContent();

	for (auto& device : m_outputDevices)
	{
		CComQIPtr<IDeckLinkProfileAttributes> deckLinkAttributes(device.second->getDeckLinkInstance());

		if (deckLinkAttributes)
		{
			LONGLONG intAttribute;
			if ((deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &intAttribute) == S_OK) &&
				(((BMDDuplexMode)intAttribute) != bmdDuplexInactive))
			{
				// Input device is active, add to combobox
				index = m_deviceListCombo.AddString(device.second->getDeviceName());
				m_deviceListCombo.SetItemDataPtr(index, (void*)device.first);

				// Retain selected device even if combo box position has changed
				if (device.second == m_selectedDevice)
					m_deviceListCombo.SetCurSel(index);
			}
		}
	}

	hasActiveOutputDevices = m_deviceListCombo.GetCount() > 0;

	// If there is at least 1 active device, enable start/stop button
	m_startButton.EnableWindow(hasActiveOutputDevices);

	if (hasActiveOutputDevices)
	{
		// If device has been removed or becomes inactive due to profile change, then select first device in combobox
		index = m_deviceListCombo.GetCurSel();
		if (index == CB_ERR)
		{
			m_deviceListCombo.SetCurSel(0);
			OnNewDeviceSelected();
		}
	}
	else
		m_selectedDevice = nullptr;

	// If a device is selected and not running then enable interface
	EnableInterface(m_selectedDevice && !m_running);
}

void CSignalGeneratorDlg::RefreshDisplayModeMenu(void)
{
	// Populate the display mode combo with a list of display modes supported by the installed DeckLink card
	m_videoFormatCombo.ResetContent();

	m_selectedDevice->queryDisplayModes([this](CComPtr<IDeckLinkDisplayMode>& displayMode)
	{
		CComBSTR			modeName;
		BMDDisplayMode		bmdDisplayMode = displayMode->GetDisplayMode();
		int					newIndex;
		BOOL				supported = FALSE;

		if (displayMode->GetName(&modeName) != S_OK)
			return;

		CString modeNameCString(modeName);
		newIndex = m_videoFormatCombo.AddString(modeNameCString);
		m_videoFormatCombo.SetItemData(newIndex, bmdDisplayMode);

		// Check Dual Stream 3D support with any pixel format
		if (!m_selectedDevice->getDeviceOutput()->DoesSupportVideoMode(bmdVideoConnectionUnspecified, bmdDisplayMode, bmdFormatUnspecified,
			bmdNoVideoOutputConversion, bmdSupportedVideoModeDualStream3D, NULL, &supported) != S_OK)
		{
			return;
		}

		if (!supported)
			return;

		CString modeName3DCString(modeName);
		modeName3DCString += _T(" 3D");
		newIndex = m_videoFormatCombo.AddString(modeName3DCString);
		m_videoFormatCombo.SetItemData(newIndex, bmdDisplayMode);
	});

	// Select first item and refresh pixel format menu
	m_videoFormatCombo.SetCurSel(0);
	OnNewVideoFormatSelected();

	m_startButton.EnableWindow(m_videoFormatCombo.GetCount() > 0);
}


void CSignalGeneratorDlg::RefreshPixelFormatMenu(void)
{
	// Populate the pixel format mode combo with a list of pixel formats supported by the installed DeckLink card
	CComPtr<IDeckLinkOutput> deckLinkOutput = m_selectedDevice->getDeviceOutput();

	m_pixelFormatCombo.ResetContent();

	for (auto& pixelFormat : kPixelFormats)
	{
		HRESULT					hr;
		int						newIndex;
		BOOL					supported;
		CString					pixelFormatString;
		BMDSupportedVideoModeFlags	flags = (m_selectedVideoOutputFlags == bmdVideoOutputDualStream3D) ? bmdSupportedVideoModeDualStream3D : bmdSupportedVideoModeDefault;

		std::tie(pixelFormatString, std::ignore) = pixelFormat.second;

		hr = deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, m_selectedDisplayMode, pixelFormat.first, bmdNoVideoOutputConversion, flags, NULL, &supported);
		if (hr != S_OK || ! supported)
			continue;

		newIndex = m_pixelFormatCombo.AddString(pixelFormatString);
		m_pixelFormatCombo.SetItemData(newIndex, pixelFormat.first);
	}

	m_pixelFormatCombo.SetCurSel(0);
}


void CSignalGeneratorDlg::RefreshAudioChannelMenu(void)
{
	CComQIPtr<IDeckLinkProfileAttributes>		deckLinkAttributes(m_selectedDevice->getDeckLinkInstance());
	LONGLONG									maxAudioChannels;

	if (!deckLinkAttributes)
		return;

	// Get max number of audio channels supported by DeckLink device
	if (deckLinkAttributes->GetInt(BMDDeckLinkMaximumAudioChannels, &maxAudioChannels) != S_OK)
		return;

	m_audioChannelCombo.ResetContent();

	// Scan through Audio channel popup menu and disable invalid entries
	for (unsigned i = 0; i < gAudioChannels.size(); i++)
	{
		if (maxAudioChannels < (LONGLONG)gAudioChannels[i])
			break;

		CString audioChannelString;
		audioChannelString.Format(_T("%d"), gAudioChannels[i]);

		m_audioChannelCombo.AddString(audioChannelString);
		m_audioChannelCombo.SetItemData(i, gAudioChannels[i]);
	}

	m_audioChannelCombo.SetCurSel(m_audioChannelCombo.GetCount() - 1);
}

// CSignalGeneratorDlg message handlers

BOOL CSignalGeneratorDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set initial dialog size as minimum size
	CRect rectWindow;
	GetWindowRect(rectWindow);
	m_minDialogSize = rectWindow.Size();
	
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// Set the item data for combo box entries to store audio channel count and sample depth information
	m_outputSignalCombo.SetItemData(0, kOutputSignalPip);
	m_outputSignalCombo.SetItemData(1, kOutputSignalDrop);
	//
	m_audioSampleDepthCombo.SetItemData(0, 16);	// 16-bit samples
	m_audioSampleDepthCombo.SetItemData(1, 32);	// 32-bit samples

	// Select the first item in each combo box
	m_outputSignalCombo.SetCurSel(0);
	m_audioSampleDepthCombo.SetCurSel(0);
	m_pixelFormatCombo.SetCurSel(0);

	//
	// Create and enable DeckLink device discovery callback interface object
	try
	{
		m_deckLinkDiscovery.Attach(new DeckLinkDeviceDiscovery());

		if (!m_deckLinkDiscovery->enable())
			throw std::runtime_error("This application requires the DeckLink drivers installed.\nPlease install the Blackmagic DeckLink drivers to use the features of this application.");
	}
	catch (const std::exception& e)
	{
		CStringW errorString(e.what());
		MessageBox(errorString, _T("Error"));
		return FALSE;
	}

	m_deckLinkDiscovery->onDeviceArrival([this](CComPtr<IDeckLink> &dl) {
		// Update UI (add new device to menu) from main thread
		PostMessage(WM_ADD_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
	});

	m_deckLinkDiscovery->onDeviceRemoval([this](CComPtr<IDeckLink> &dl) {
		// Update UI (remove device from menu) from main thread
		PostMessage(WM_REMOVE_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
		dl.Release();
	});

	// Create and initialize preview helper
	m_previewWindow.Attach(new PreviewWindow());
	if (m_previewWindow->init(&m_previewBox) == false)
	{
		MessageBox(_T("This application was unable to initialise the preview window"), _T("Error"));
		return FALSE;
	}

	// Create profile callback interface object
	m_profileCallback.Attach(new ProfileCallback());
	if (!m_profileCallback)
	{
		MessageBox(_T("This application was unable to create profile callback class"), _T("Error"));
		return FALSE;
	}

	m_profileCallback->onHaltStreams(std::bind(&CSignalGeneratorDlg::HaltStreams, this, std::placeholders::_1));
	m_profileCallback->onProfileActivated([this](CComPtr<IDeckLinkProfile>& /* unused */) {
		// Update UI with new profile
		PostMessage(WM_UPDATE_PROFILE_MESSAGE, 0, 0);
	});

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSignalGeneratorDlg::EnableInterface (BOOL enable)
{
	// Set the enable state of user interface elements
	m_deviceListCombo.EnableWindow(enable);
	m_outputSignalCombo.EnableWindow(enable);
	m_audioChannelCombo.EnableWindow(enable);
	m_audioSampleDepthCombo.EnableWindow(enable);
	m_videoFormatCombo.EnableWindow(enable);
	m_pixelFormatCombo.EnableWindow(enable);
}

void CSignalGeneratorDlg::OnBnClickedOk()
{
	if (m_running == false)
		StartRunning();
	else
		StopRunning();
}

void CSignalGeneratorDlg::OnNewDeviceSelected()
{
	int selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	if (m_selectedDevice)
	{
		// Unsubscribe to output device callbacks
		m_selectedDevice->onScheduledFrameCompleted(nullptr);
		m_selectedDevice->onRenderAudioSamples(nullptr);
		m_selectedDevice->onScheduledPlaybackStopped(nullptr);
		m_selectedDevice->setErrorListener(nullptr);

		m_selectedDevice.Release();
	}
	
	// Find output device based on IDeckLink* object
	auto iter = m_outputDevices.find((IDeckLink*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex));
	if (iter == m_outputDevices.end())
		return;

	m_selectedDevice = iter->second;

	// Register profile callback with newly selected device's profile manager
	if (m_selectedDevice)
	{
		// Check whether HFRTC is supported by the selected device
		CComQIPtr<IDeckLinkProfileAttributes> deckLinkAttributes = m_selectedDevice->getDeckLinkInstance();
		if (!deckLinkAttributes || (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsHighFrameRateTimecode, &m_hfrtcSupported) != S_OK))
		{
			m_hfrtcSupported = FALSE;
		}

		// Subscribe to output device callbacks
		m_selectedDevice->onScheduledFrameCompleted(std::bind(&CSignalGeneratorDlg::ScheduleNextFrame, this, false));
		m_selectedDevice->onRenderAudioSamples(std::bind(&CSignalGeneratorDlg::WriteNextAudioSamples, this, std::placeholders::_1));
		m_selectedDevice->onScheduledPlaybackStopped(std::bind(&CSignalGeneratorDlg::ScheduledPlaybackStopped, this));
		m_selectedDevice->setErrorListener(std::bind(&CSignalGeneratorDlg::HandleDeviceError, this, std::placeholders::_1));
	}

	// Update the video mode popup menu
	RefreshDisplayModeMenu();

	// Update available audio channels
	RefreshAudioChannelMenu();
}


void CSignalGeneratorDlg::OnNewVideoFormatSelected()
{
	int					selectedVideoFormatIndex;
	CString				videoFormatName;

	selectedVideoFormatIndex = m_videoFormatCombo.GetCurSel();
	if (selectedVideoFormatIndex < 0)
		return;

	m_selectedDisplayMode = (BMDDisplayMode)m_videoFormatCombo.GetItemData(selectedVideoFormatIndex);
	
	m_videoFormatCombo.GetLBText(selectedVideoFormatIndex, videoFormatName);
	m_selectedVideoOutputFlags = (videoFormatName.Find(_T(" 3D"), 0) != -1) ? bmdVideoOutputDualStream3D : bmdVideoOutputFlagDefault;

	if (m_selectedDisplayMode == bmdModeNTSC ||
		m_selectedDisplayMode == bmdModeNTSC2398 ||
		m_selectedDisplayMode == bmdModePAL)
	{
		m_timeCodeFormat = bmdTimecodeVITC;
		m_selectedVideoOutputFlags = (BMDVideoOutputFlags)(m_selectedVideoOutputFlags | bmdVideoOutputVITC);
	}
	else
	{
		m_timeCodeFormat = bmdTimecodeRP188Any;
		m_selectedVideoOutputFlags = (BMDVideoOutputFlags)(m_selectedVideoOutputFlags | bmdVideoOutputRP188);
	}

	RefreshPixelFormatMenu();
}

void CSignalGeneratorDlg::AddDevice(CComPtr<IDeckLink>& deckLink)
{
	CComPtr<DeckLinkOutputDevice>	newDevice;

	newDevice.Attach(new DeckLinkOutputDevice(deckLink));

	// Initialise new DeckLinkDevice object
	if (!newDevice->init())
		// Device does not have IDeckLinkOutput interface, eg it is a DeckLink Mini Recorder
		return;

	// Register profile callback with newly added device's profile manager
	CComQIPtr<IDeckLinkProfileManager> profileManager(newDevice->getDeckLinkInstance());
	if (profileManager)
		profileManager->SetCallback(m_profileCallback);

	// Store output device to map to maintain reference
	m_outputDevices[deckLink] = std::move(newDevice);
	
	RefreshOutputDeviceList();
}

void CSignalGeneratorDlg::RemoveDevice(CComPtr<IDeckLink>& deckLink)
{
	// Remove output device from list 
	auto iter = m_outputDevices.find(deckLink);
	if (iter != m_outputDevices.end())
	{
		CComPtr<DeckLinkOutputDevice> deviceToRemove = iter->second;

		if ((deviceToRemove == m_selectedDevice) && m_running)
			StopRunning();

		// Release profile callback from device to remove
		CComQIPtr<IDeckLinkProfileManager> profileManager(deviceToRemove->getDeckLinkInstance());
		if (profileManager)
			profileManager->SetCallback(nullptr);

		// Release DeckLinkDevice instance
		deviceToRemove.Release();

		m_outputDevices.erase(iter);

		// Update output device combo box
		RefreshOutputDeviceList();
	}
}

static int GetRowBytes(BMDPixelFormat pixelFormat, int frameWidth)
{
	int bytesPerRow;

	// Refer to DeckLink SDK Manual - 3.4 Pixel Formats
	switch (pixelFormat)
	{
	case bmdFormat8BitYUV:
		bytesPerRow = frameWidth * 2;
		break;

	case bmdFormat10BitYUV:
		bytesPerRow = ((frameWidth + 47) / 48) * 128;
		break;

	case bmdFormat10BitRGB:
		bytesPerRow = ((frameWidth + 63) / 64) * 256;
		break;

	case bmdFormat8BitARGB:
	case bmdFormat8BitBGRA:
	default:
		bytesPerRow = frameWidth * 4;
		break;
	}

	return bytesPerRow;
}

CComPtr<SignalGenerator3DVideoFrame> CSignalGeneratorDlg::CreateOutputFrame(FillFrameFunction fillFrame)
{
	CComPtr<IDeckLinkOutput>				deckLinkOutput;
	CComPtr<IDeckLinkMutableVideoFrame>		referenceFrameLeft;
	CComPtr<IDeckLinkMutableVideoFrame>		referenceFrameRight;
	CComPtr<IDeckLinkMutableVideoFrame>		scheduleFrameLeft;
	CComPtr<IDeckLinkMutableVideoFrame>		scheduleFrameRight;
	BMDPixelFormat							pixelFormat;
	int										bytesPerRow;
	int										referenceBytesPerRow;
	CComPtr<IDeckLinkVideoConversion>		frameConverter;
	CComPtr<SignalGenerator3DVideoFrame>	returnFrame;

	pixelFormat = (BMDPixelFormat)m_pixelFormatCombo.GetItemData(m_pixelFormatCombo.GetCurSel());
	bytesPerRow = GetRowBytes(pixelFormat, m_frameWidth);
	referenceBytesPerRow = GetRowBytes(bmdFormat8BitYUV, m_frameWidth);

	deckLinkOutput = m_selectedDevice->getDeviceOutput();

	if (frameConverter.CoCreateInstance(CLSID_CDeckLinkVideoConversion, NULL, CLSCTX_ALL) != S_OK)
	{
		MessageBox(_T("Could create video conversion interface"), _T("Error"));
		return nullptr;
	}

	if (deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, referenceBytesPerRow, bmdFormat8BitYUV, bmdFrameFlagDefault, &referenceFrameLeft) != S_OK)
	{
		MessageBox(_T("Could create video output frame"), _T("Error"));
		return nullptr;
	}

	fillFrame(referenceFrameLeft, false);

	if (pixelFormat == bmdFormat8BitYUV)
	{
		// Frame is already 8-bit YUV, no conversion required
		scheduleFrameLeft = referenceFrameLeft;
	}
	else
	{
		if (deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, bytesPerRow, pixelFormat, bmdFrameFlagDefault, &scheduleFrameLeft) != S_OK)
		{
			MessageBox(_T("Could create video output frame"), _T("Error"));
			return nullptr;
		}

		if (frameConverter->ConvertFrame(referenceFrameLeft, scheduleFrameLeft) != S_OK)
		{
			MessageBox(_T("Could convert video output frame"), _T("Error"));
			return nullptr;
		}
	}

	// If dual-stream 3D, generate right-eye frame
	if (m_selectedVideoOutputFlags == bmdVideoOutputDualStream3D)
	{
		if (deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, referenceBytesPerRow, bmdFormat8BitYUV, bmdFrameFlagDefault, &referenceFrameRight) != S_OK)
		{
			MessageBox(_T("Could create video output frame"), _T("Error"));
			return nullptr;
		}

		fillFrame(referenceFrameRight, true);

		if (pixelFormat == bmdFormat8BitYUV)
		{
			// Frame is already 8-bit YUV, no conversion required
			scheduleFrameRight = referenceFrameRight;
		}
		else
		{
			if (deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, bytesPerRow, pixelFormat, bmdFrameFlagDefault, &scheduleFrameRight) != S_OK)
			{
				MessageBox(_T("Could create video output frame"), _T("Error"));
				return nullptr;
			}

			if (frameConverter->ConvertFrame(referenceFrameRight, scheduleFrameRight) != S_OK)
			{
				MessageBox(_T("Could convert video output frame"), _T("Error"));
				return nullptr;
			}
		}
	}

	returnFrame.Attach(new SignalGenerator3DVideoFrame(scheduleFrameLeft, scheduleFrameRight));
	return returnFrame;
}

void	CSignalGeneratorDlg::StartRunning ()
{
	CComPtr<IDeckLinkOutput>			deckLinkOutput = m_selectedDevice->getDeviceOutput();
	CComPtr<IDeckLinkDisplayMode>		displayMode;
	BOOL								output444;
	HRESULT								result;

	// Determine the audio and video properties for the output stream
	m_outputSignal = (OutputSignal)m_outputSignalCombo.GetCurSel();
	m_audioChannelCount = m_audioChannelCombo.GetItemData(m_audioChannelCombo.GetCurSel());
	m_audioSampleDepth = (BMDAudioSampleType)m_audioSampleDepthCombo.GetItemData(m_audioSampleDepthCombo.GetCurSel());
	m_audioSampleRate = bmdAudioSampleRate48kHz;
	//
	// - Extract the IDeckLinkDisplayMode from the selected BMDDisplayMode
	if (deckLinkOutput->GetDisplayMode(m_selectedDisplayMode, &displayMode) != S_OK)
		goto bail;

	m_frameWidth = (int)displayMode->GetWidth();
	m_frameHeight = (int)displayMode->GetHeight();
	m_fieldDominance = displayMode->GetFieldDominance();
	displayMode->GetFrameRate(&m_frameDuration, &m_frameTimescale);
	// Calculate the number of frames per second, rounded up to the nearest integer.  For example, for NTSC (29.97 FPS), framesPerSecond == 30.
	m_framesPerSecond = (unsigned long)((m_frameTimescale + (m_frameDuration-1))  /  m_frameDuration);
	
	// Set the video preroll size and audio waterlevel to 1/2 second
	m_selectedDevice->setVideoPrerollSize(m_framesPerSecond / 2);
	m_selectedDevice->setAudioWaterLevel(bmdAudioSampleRate48kHz / 2);

	// m-rate frame rates with multiple 30-frame counting should implement Drop Frames compensation, refer to SMPTE 12-1
	if (m_frameDuration == 1001 && m_frameTimescale % 30000 == 0)
		m_dropFrames = (unsigned int)(2 * (m_frameTimescale / 30000));
	else
		m_dropFrames = 0;

	m_timeCode = std::make_unique<Timecode>(m_framesPerSecond, m_dropFrames);

	// Set the output to 444 if RGB mode is selected
	try
	{
		std::tie(std::ignore, output444) = kPixelFormats.at((BMDPixelFormat)m_pixelFormatCombo.GetItemData(m_pixelFormatCombo.GetCurSel()));
	}
	catch (std::out_of_range)
	{
		goto bail;
	}

	result = m_selectedDevice->getDeviceConfiguration()->SetFlag(bmdDeckLinkConfig444SDIVideoOutput, output444);
	// If a device without SDI output is used, then SetFlags will return E_NOTIMPL
	if ((result != S_OK) && (result != E_NOTIMPL))
		goto bail;

	// Set the video output mode
	if (deckLinkOutput->EnableVideoOutput(m_selectedDisplayMode, m_selectedVideoOutputFlags) != S_OK)
		goto bail;

	// Set the audio output mode
	if (deckLinkOutput->EnableAudioOutput(bmdAudioSampleRate48kHz, m_audioSampleDepth, m_audioChannelCount, bmdAudioOutputStreamTimestamped) != S_OK)
		goto bail;
	
	// Set Video, audio and screen preview callbacks with DeckLinkOutputDevice delegate
	deckLinkOutput->SetScheduledFrameCompletionCallback(m_selectedDevice);
	deckLinkOutput->SetAudioCallback(m_selectedDevice);
	deckLinkOutput->SetScreenPreviewCallback(m_previewWindow);

	// Generate one second of audio tone
	m_audioSamplesPerFrame = (unsigned long)((m_audioSampleRate * m_frameDuration) / m_frameTimescale);
	m_audioBufferSampleLength = (unsigned long)((m_framesPerSecond * m_audioSampleRate * m_frameDuration) / m_frameTimescale);
	m_audioBuffer.resize(m_audioBufferSampleLength * m_audioChannelCount * (m_audioSampleDepth / 8), 0x0);  // Zero buffer  (interpreted as audio silence)
	m_audioBufferOffset = 0;
	m_audioStreamTime = 0;

	if (m_outputSignal == kOutputSignalPip)
		FillSine(m_audioBuffer.data(), m_audioSamplesPerFrame, m_audioChannelCount, m_audioSampleDepth);
	else
		FillSine(m_audioBuffer.data() + (m_audioSamplesPerFrame * m_audioChannelCount * m_audioSampleDepth / 8), (m_audioBufferSampleLength - m_audioSamplesPerFrame), m_audioChannelCount, m_audioSampleDepth);

	// Generate a frame of black
	m_videoFrameBlack = CreateOutputFrame(FillBlack);
	if (! m_videoFrameBlack)
		goto bail;

	// Generate a frame of colour bars
	m_videoFrameBars = CreateOutputFrame(FillColourBars);
	if (! m_videoFrameBars)
		goto bail;

	// Begin video preroll by scheduling half a second of frames in hardware
	for (unsigned i = 0; i < m_framesPerSecond / 2; i++)
		ScheduleNextFrame(true);
	
	// Begin audio preroll.  This will begin calling our audio callback, which will start the DeckLink output stream.
	if (deckLinkOutput->BeginAudioPreroll() != S_OK)
		goto bail;
	
	{
		std::lock_guard<std::mutex> lock(m_stopPlaybackMutex);
		m_scheduledPlaybackStopped = false;
	}

	// Success; update the UI
	m_running = true;
	m_startButton.SetWindowText(_T("Stop"));
	// Disable the user interface while running (prevent the user from making changes to the output signal)
	EnableInterface(FALSE);
	
	return;
	
bail:
	// *** Error-handling code.  Cleanup any resources that were allocated. *** //
	StopRunning();
}


void	CSignalGeneratorDlg::StopRunning ()
{
	CComPtr<IDeckLinkOutput> deckLinkOutput = m_selectedDevice->getDeviceOutput();

	// Stop the audio and video output streams immediately
	deckLinkOutput->StopScheduledPlayback(0, nullptr, 0);

	// Recommended to wait for IDeckLinkVideoOutputCallback::ScheduledPlaybackHasStopped callback before disabling output
	{
		std::unique_lock<std::mutex> lock(m_stopPlaybackMutex);
		m_stopPlaybackCondition.wait(lock, [&] { return m_scheduledPlaybackStopped; });
	}

	// Dereference DeckLinkOutputDevice delegate from callbacks
	deckLinkOutput->SetScheduledFrameCompletionCallback(nullptr);
	deckLinkOutput->SetAudioCallback(nullptr);
	deckLinkOutput->SetScreenPreviewCallback(nullptr);

	// Disable video and audio outputs
	deckLinkOutput->DisableAudioOutput();
	deckLinkOutput->DisableVideoOutput();

	// Success; update the UI
	m_running = false;
	m_startButton.SetWindowText(_T("Start"));
	// Re-enable the user interface when stopped
	EnableInterface(TRUE);
}


void	CSignalGeneratorDlg::ScheduleNextFrame (bool prerolling)
{
	CComPtr<IDeckLinkOutput>				deckLinkOutput = m_selectedDevice->getDeviceOutput();
	CComPtr<SignalGenerator3DVideoFrame>	currentFrame;
	bool									setVITC1Timecode = false;
	bool									setVITC2Timecode = false;
	unsigned long							totalFramesScheduled = m_timeCode->frameCount();

	if (prerolling == false)
	{
		// If not prerolling, make sure that playback is still active
		if (m_running == false)
			return;
	}
	
	if (m_outputSignal == kOutputSignalPip)
	{
		if ((totalFramesScheduled % m_framesPerSecond) == 0)
		{
			// On each second, schedule a frame of bars
			currentFrame = m_videoFrameBars;
		}
		else
		{
			// Schedue frames of black
			currentFrame = m_videoFrameBlack;
		}
	}
	else
	{
		if ((totalFramesScheduled % m_framesPerSecond) == 0)
		{
			// On each second, schedule a frame of black
			currentFrame = m_videoFrameBlack;
		}
		else
		{
			// Schedue frames of color bars
			currentFrame = m_videoFrameBars;
		}
	}

	// Clear old timecodes from frame
	currentFrame->SetTimecode(bmdTimecodeVITC, nullptr);
	currentFrame->SetTimecode(bmdTimecodeRP188VITC1, nullptr);
	currentFrame->SetTimecode(bmdTimecodeRP188VITC2, nullptr);
	currentFrame->SetTimecode(bmdTimecodeRP188HighFrameRate, nullptr);

	if (m_timeCodeFormat == bmdTimecodeVITC)
	{
		if (currentFrame->SetTimecodeFromComponents(bmdTimecodeVITC,
			m_timeCode->hours(),
			m_timeCode->minutes(),
			m_timeCode->seconds(),
			m_timeCode->frames(),
			bmdTimecodeFlagDefault) != S_OK)
		{
			MessageBox(_T("Could not set VITC timecode on frame"), _T("Error"));
			goto bail;
		}
	}
	else
	{
		int frames = m_timeCode->frames();

		if (m_hfrtcSupported)
		{
			if (currentFrame->SetTimecodeFromComponents(bmdTimecodeRP188HighFrameRate,
				m_timeCode->hours(),
				m_timeCode->minutes(),
				m_timeCode->seconds(),
				frames,
				bmdTimecodeFlagDefault) != S_OK)
			{
				MessageBox(_T("Could not set HFRTC timecode on frame"), _T("Error"));
				goto bail;
			}
		}

		if (m_fieldDominance != bmdProgressiveFrame)
		{
			// An interlaced or PsF frame has both VITC1 and VITC2 set with the same timecode value (SMPTE ST 12-2:2014 7.2)
			setVITC1Timecode = true;
			setVITC2Timecode = true;
		}
		else if (m_framesPerSecond <= 30)
		{
			// If this isn't a High-P mode, then just use VITC1 (SMPTE ST 12-2:2014 7.2)
			setVITC1Timecode = true;
		}
		else if (m_framesPerSecond <= 60)
		{
			// If this is a High-P mode then use VITC1 on even frames and VITC2 on odd frames. This is done because the
			// frames field of the RP188 VITC timecode cannot hold values greater than 30 (SMPTE ST 12-2:2014 7.2, 9.2)
			if ((frames & 1) == 0)
				setVITC1Timecode = true;
			else
				setVITC2Timecode = true;

			frames >>= 1;
		}

		if (setVITC1Timecode)
		{
			if (currentFrame->SetTimecodeFromComponents(bmdTimecodeRP188VITC1,
				m_timeCode->hours(),
				m_timeCode->minutes(),
				m_timeCode->seconds(),
				frames,
				bmdTimecodeFlagDefault) != S_OK)
			{
				MessageBox(_T("Could not set VITC1 timecode on interlaced frame"), _T("Error"));
				goto bail;
			}
		}

		if (setVITC2Timecode)
		{
			// The VITC2 timecode also has the field mark flag set
			if (currentFrame->SetTimecodeFromComponents(bmdTimecodeRP188VITC2,
				m_timeCode->hours(),
				m_timeCode->minutes(),
				m_timeCode->seconds(),
				frames,
				bmdTimecodeFieldMark) != S_OK)
			{
				MessageBox(_T("Could not set VITC1 timecode on interlaced frame"), _T("Error"));
				goto bail;
			}
		}
	}

	deckLinkOutput->ScheduleVideoFrame(currentFrame, (totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale);

bail:
	m_timeCode->update();
}

void	CSignalGeneratorDlg::WriteNextAudioSamples(unsigned int samplesToWrite)
{
	CComPtr<IDeckLinkOutput>	deckLinkOutput = m_selectedDevice->getDeviceOutput();
	unsigned int				samplesToEndOfBuffer;
	unsigned int				samplesWritten;

	samplesToEndOfBuffer = (m_audioBufferSampleLength - m_audioBufferOffset);
	if (samplesToWrite > samplesToEndOfBuffer)
		samplesToWrite = samplesToEndOfBuffer;

	HRESULT hr = deckLinkOutput->ScheduleAudioSamples((void*)(m_audioBuffer.data() + m_audioBufferOffset * m_audioChannelCount * m_audioSampleDepth / 8), samplesToWrite, m_audioStreamTime, m_audioSampleRate, &samplesWritten);
	if (hr == S_OK)
	{
		m_audioBufferOffset = ((m_audioBufferOffset + samplesWritten) % m_audioBufferSampleLength);
		m_audioStreamTime += samplesWritten;
	}
}

void	CSignalGeneratorDlg::ScheduledPlaybackStopped()
{
	// Notify waiting process that scheduled playback has stopped
	std::lock_guard<std::mutex> guard(m_stopPlaybackMutex);
	m_scheduledPlaybackStopped = true;
	m_stopPlaybackCondition.notify_all();
}

void	CSignalGeneratorDlg::HaltStreams(CComPtr<IDeckLinkProfile>& newProfile)
{
	CComPtr<IDeckLink> deckLink;

	// Profile is changing, stop playback if running
	if ((newProfile->GetDevice(&deckLink) == S_OK) &&
		(m_selectedDevice->getDeckLinkInstance() == deckLink) &&
		m_running)
	{
		StopRunning();
	}
}

void CSignalGeneratorDlg::HandleDeviceError(OutputDeviceError error)
{
	switch (error)
	{
		case OutputDeviceError::GetBufferedAudioSampleCountFailed:
			MessageBox(_T("Could not obtain the buffered audio sample count"), _T("Error"));
			break;

		case OutputDeviceError::GetBufferedVideoFrameCountFailed:
			MessageBox(_T("Could not obtain the buffered video frame count"), _T("Error"));
			break;
	}
}

LRESULT CSignalGeneratorDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	AddDevice(deckLink);
	return 0;
}

LRESULT	CSignalGeneratorDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	RemoveDevice(deckLink);
	return 0;
}

LRESULT	CSignalGeneratorDlg::OnProfileUpdate(WPARAM wParam, LPARAM lParam)
{
	// Check whether device is active/inactive and update output device combobox, 
	// following the same steps as if the device was added/removed. 
	RefreshOutputDeviceList();
	return 0;
}


// Required to ensure minimum szie of dialog
void CSignalGeneratorDlg::OnGetMinMaxInfo(MINMAXINFO* minMaxInfo)
{
	CDialog::OnGetMinMaxInfo(minMaxInfo);

	minMaxInfo->ptMinTrackSize.x = std::max(minMaxInfo->ptMinTrackSize.x, m_minDialogSize.cx);
	minMaxInfo->ptMinTrackSize.y = std::max(minMaxInfo->ptMinTrackSize.y, m_minDialogSize.cy);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSignalGeneratorDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void CSignalGeneratorDlg::OnClose()
{
	if (m_running)
		StopRunning();

	if (m_selectedDevice)
		m_selectedDevice.Release();

	// Release all output devices
	for (auto& device : m_outputDevices)
	{
		CComQIPtr<IDeckLinkProfileManager> profileManager(device.second->getDeckLinkInstance());
		if (profileManager)
			profileManager->SetCallback(nullptr);

		device.second.Release();
	}

	// Release profile callback
	m_profileCallback.Release();

	// Release preview window
	m_previewWindow.Release();

	// Disable DeckLink device discovery
	m_deckLinkDiscovery->disable();
	m_deckLinkDiscovery.Release();

	CDialog::OnClose();
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSignalGeneratorDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



/*****************************************/


void	FillSine (unsigned char* audioBuffer, unsigned long samplesToWrite, unsigned long channels, unsigned long sampleDepth)
{
	int audioMaxLevel = (1 << ((int)sampleDepth - 1)) - 1;
	double toneMaxLevel = (double)audioMaxLevel * pow(10.0, kReferenceAudioToneLevel / kReferenceSoundPressure);

	if (sampleDepth == bmdAudioSampleType16bitInteger)
	{
		int16_t* nextBuffer;
		
		nextBuffer = (int16_t*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			int16_t sample;
			
			sample = (int16_t)(toneMaxLevel * sin((i * 2.0 * M_PI * kReferenceAudioToneFreq) / (int)bmdAudioSampleRate48kHz));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
	else if (sampleDepth == bmdAudioSampleType32bitInteger)
	{
		int32_t* nextBuffer;
		
		nextBuffer = (int32_t*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			int32_t sample;
			
			sample = (int32_t)(toneMaxLevel * sin((i * 2.0 * M_PI * kReferenceAudioToneFreq) / (int)bmdAudioSampleRate48kHz));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
}

void	FillColourBars (CComPtr<IDeckLinkMutableVideoFrame>& theFrame, bool reversed)
{
	DWORD*			nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned long	colourBarCount;
	
	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();
	
	auto& bars = (width > 720) ? gHD75pcColourBars : gSD75pcColourBars;
	colourBarCount = bars.size();

	for (unsigned y = 0; y < height; y++)
	{
		for (unsigned x = 0; x < width; x+=2)
		{
			int pos = x * colourBarCount / width;

			if (reversed)
				pos = colourBarCount - pos - 1;

			*(nextWord++) = bars[pos];
		}
	}
}

void	FillBlack (CComPtr<IDeckLinkMutableVideoFrame>& theFrame, bool /* unused */ )
{
	DWORD*			nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned long	wordsRemaining;
	
	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();
	
	wordsRemaining = (width*2 * height) / 4;
	
	while (wordsRemaining-- > 0)
		*(nextWord++) = 0x10801080;
}

